/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  BaseView: () => BaseView,
  VIEW_TYPE: () => VIEW_TYPE,
  default: () => Crafty
});
module.exports = __toCommonJS(main_exports);

// node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/css-tag.js
var t = globalThis;
var e = t.ShadowRoot && (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s = Symbol();
var o = /* @__PURE__ */ new WeakMap();
var n = class {
  constructor(t7, e11, o10) {
    if (this._$cssResult$ = true, o10 !== s)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t7, this.t = e11;
  }
  get styleSheet() {
    let t7 = this.o;
    const s5 = this.t;
    if (e && void 0 === t7) {
      const e11 = void 0 !== s5 && 1 === s5.length;
      e11 && (t7 = o.get(s5)), void 0 === t7 && ((this.o = t7 = new CSSStyleSheet()).replaceSync(this.cssText), e11 && o.set(s5, t7));
    }
    return t7;
  }
  toString() {
    return this.cssText;
  }
};
var r = (t7) => new n("string" == typeof t7 ? t7 : t7 + "", void 0, s);
var i = (t7, ...e11) => {
  const o10 = 1 === t7.length ? t7[0] : e11.reduce((e12, s5, o11) => e12 + ((t8) => {
    if (true === t8._$cssResult$)
      return t8.cssText;
    if ("number" == typeof t8)
      return t8;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t8 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s5) + t7[o11 + 1], t7[0]);
  return new n(o10, t7, s);
};
var S = (s5, o10) => {
  if (e)
    s5.adoptedStyleSheets = o10.map((t7) => t7 instanceof CSSStyleSheet ? t7 : t7.styleSheet);
  else
    for (const e11 of o10) {
      const o11 = document.createElement("style"), n7 = t.litNonce;
      void 0 !== n7 && o11.setAttribute("nonce", n7), o11.textContent = e11.cssText, s5.appendChild(o11);
    }
};
var c = e ? (t7) => t7 : (t7) => t7 instanceof CSSStyleSheet ? ((t8) => {
  let e11 = "";
  for (const s5 of t8.cssRules)
    e11 += s5.cssText;
  return r(e11);
})(t7) : t7;

// node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/reactive-element.js
var { is: i2, defineProperty: e2, getOwnPropertyDescriptor: r2, getOwnPropertyNames: h, getOwnPropertySymbols: o2, getPrototypeOf: n2 } = Object;
var a = globalThis;
var c2 = a.trustedTypes;
var l = c2 ? c2.emptyScript : "";
var p = a.reactiveElementPolyfillSupport;
var d = (t7, s5) => t7;
var u = { toAttribute(t7, s5) {
  switch (s5) {
    case Boolean:
      t7 = t7 ? l : null;
      break;
    case Object:
    case Array:
      t7 = null == t7 ? t7 : JSON.stringify(t7);
  }
  return t7;
}, fromAttribute(t7, s5) {
  let i6 = t7;
  switch (s5) {
    case Boolean:
      i6 = null !== t7;
      break;
    case Number:
      i6 = null === t7 ? null : Number(t7);
      break;
    case Object:
    case Array:
      try {
        i6 = JSON.parse(t7);
      } catch (t8) {
        i6 = null;
      }
  }
  return i6;
} };
var f = (t7, s5) => !i2(t7, s5);
var y = { attribute: true, type: String, converter: u, reflect: false, hasChanged: f };
var _a, _b;
(_a = Symbol.metadata) != null ? _a : Symbol.metadata = Symbol("metadata"), (_b = a.litPropertyMetadata) != null ? _b : a.litPropertyMetadata = /* @__PURE__ */ new WeakMap();
var b = class extends HTMLElement {
  static addInitializer(t7) {
    var _a6;
    this._$Ei(), ((_a6 = this.l) != null ? _a6 : this.l = []).push(t7);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t7, s5 = y) {
    if (s5.state && (s5.attribute = false), this._$Ei(), this.elementProperties.set(t7, s5), !s5.noAccessor) {
      const i6 = Symbol(), r8 = this.getPropertyDescriptor(t7, i6, s5);
      void 0 !== r8 && e2(this.prototype, t7, r8);
    }
  }
  static getPropertyDescriptor(t7, s5, i6) {
    var _a6;
    const { get: e11, set: h3 } = (_a6 = r2(this.prototype, t7)) != null ? _a6 : { get() {
      return this[s5];
    }, set(t8) {
      this[s5] = t8;
    } };
    return { get() {
      return e11 == null ? void 0 : e11.call(this);
    }, set(s6) {
      const r8 = e11 == null ? void 0 : e11.call(this);
      h3.call(this, s6), this.requestUpdate(t7, r8, i6);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t7) {
    var _a6;
    return (_a6 = this.elementProperties.get(t7)) != null ? _a6 : y;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d("elementProperties")))
      return;
    const t7 = n2(this);
    t7.finalize(), void 0 !== t7.l && (this.l = [...t7.l]), this.elementProperties = new Map(t7.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d("finalized")))
      return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d("properties"))) {
      const t8 = this.properties, s5 = [...h(t8), ...o2(t8)];
      for (const i6 of s5)
        this.createProperty(i6, t8[i6]);
    }
    const t7 = this[Symbol.metadata];
    if (null !== t7) {
      const s5 = litPropertyMetadata.get(t7);
      if (void 0 !== s5)
        for (const [t8, i6] of s5)
          this.elementProperties.set(t8, i6);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t8, s5] of this.elementProperties) {
      const i6 = this._$Eu(t8, s5);
      void 0 !== i6 && this._$Eh.set(i6, t8);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s5) {
    const i6 = [];
    if (Array.isArray(s5)) {
      const e11 = new Set(s5.flat(1 / 0).reverse());
      for (const s6 of e11)
        i6.unshift(c(s6));
    } else
      void 0 !== s5 && i6.push(c(s5));
    return i6;
  }
  static _$Eu(t7, s5) {
    const i6 = s5.attribute;
    return false === i6 ? void 0 : "string" == typeof i6 ? i6 : "string" == typeof t7 ? t7.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var _a6;
    this._$ES = new Promise((t7) => this.enableUpdating = t7), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (_a6 = this.constructor.l) == null ? void 0 : _a6.forEach((t7) => t7(this));
  }
  addController(t7) {
    var _a6, _b3;
    ((_a6 = this._$EO) != null ? _a6 : this._$EO = /* @__PURE__ */ new Set()).add(t7), void 0 !== this.renderRoot && this.isConnected && ((_b3 = t7.hostConnected) == null ? void 0 : _b3.call(t7));
  }
  removeController(t7) {
    var _a6;
    (_a6 = this._$EO) == null ? void 0 : _a6.delete(t7);
  }
  _$E_() {
    const t7 = /* @__PURE__ */ new Map(), s5 = this.constructor.elementProperties;
    for (const i6 of s5.keys())
      this.hasOwnProperty(i6) && (t7.set(i6, this[i6]), delete this[i6]);
    t7.size > 0 && (this._$Ep = t7);
  }
  createRenderRoot() {
    var _a6;
    const t7 = (_a6 = this.shadowRoot) != null ? _a6 : this.attachShadow(this.constructor.shadowRootOptions);
    return S(t7, this.constructor.elementStyles), t7;
  }
  connectedCallback() {
    var _a6, _b3;
    (_a6 = this.renderRoot) != null ? _a6 : this.renderRoot = this.createRenderRoot(), this.enableUpdating(true), (_b3 = this._$EO) == null ? void 0 : _b3.forEach((t7) => {
      var _a7;
      return (_a7 = t7.hostConnected) == null ? void 0 : _a7.call(t7);
    });
  }
  enableUpdating(t7) {
  }
  disconnectedCallback() {
    var _a6;
    (_a6 = this._$EO) == null ? void 0 : _a6.forEach((t7) => {
      var _a7;
      return (_a7 = t7.hostDisconnected) == null ? void 0 : _a7.call(t7);
    });
  }
  attributeChangedCallback(t7, s5, i6) {
    this._$AK(t7, i6);
  }
  _$EC(t7, s5) {
    var _a6;
    const i6 = this.constructor.elementProperties.get(t7), e11 = this.constructor._$Eu(t7, i6);
    if (void 0 !== e11 && true === i6.reflect) {
      const r8 = (void 0 !== ((_a6 = i6.converter) == null ? void 0 : _a6.toAttribute) ? i6.converter : u).toAttribute(s5, i6.type);
      this._$Em = t7, null == r8 ? this.removeAttribute(e11) : this.setAttribute(e11, r8), this._$Em = null;
    }
  }
  _$AK(t7, s5) {
    var _a6;
    const i6 = this.constructor, e11 = i6._$Eh.get(t7);
    if (void 0 !== e11 && this._$Em !== e11) {
      const t8 = i6.getPropertyOptions(e11), r8 = "function" == typeof t8.converter ? { fromAttribute: t8.converter } : void 0 !== ((_a6 = t8.converter) == null ? void 0 : _a6.fromAttribute) ? t8.converter : u;
      this._$Em = e11, this[e11] = r8.fromAttribute(s5, t8.type), this._$Em = null;
    }
  }
  requestUpdate(t7, s5, i6) {
    var _a6;
    if (void 0 !== t7) {
      if (i6 != null ? i6 : i6 = this.constructor.getPropertyOptions(t7), !((_a6 = i6.hasChanged) != null ? _a6 : f)(this[t7], s5))
        return;
      this.P(t7, s5, i6);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t7, s5, i6) {
    var _a6;
    this._$AL.has(t7) || this._$AL.set(t7, s5), true === i6.reflect && this._$Em !== t7 && ((_a6 = this._$Ej) != null ? _a6 : this._$Ej = /* @__PURE__ */ new Set()).add(t7);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t8) {
      Promise.reject(t8);
    }
    const t7 = this.scheduleUpdate();
    return null != t7 && await t7, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var _a6, _b3;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if ((_a6 = this.renderRoot) != null ? _a6 : this.renderRoot = this.createRenderRoot(), this._$Ep) {
        for (const [t9, s6] of this._$Ep)
          this[t9] = s6;
        this._$Ep = void 0;
      }
      const t8 = this.constructor.elementProperties;
      if (t8.size > 0)
        for (const [s6, i6] of t8)
          true !== i6.wrapped || this._$AL.has(s6) || void 0 === this[s6] || this.P(s6, this[s6], i6);
    }
    let t7 = false;
    const s5 = this._$AL;
    try {
      t7 = this.shouldUpdate(s5), t7 ? (this.willUpdate(s5), (_b3 = this._$EO) == null ? void 0 : _b3.forEach((t8) => {
        var _a7;
        return (_a7 = t8.hostUpdate) == null ? void 0 : _a7.call(t8);
      }), this.update(s5)) : this._$EU();
    } catch (s6) {
      throw t7 = false, this._$EU(), s6;
    }
    t7 && this._$AE(s5);
  }
  willUpdate(t7) {
  }
  _$AE(t7) {
    var _a6;
    (_a6 = this._$EO) == null ? void 0 : _a6.forEach((t8) => {
      var _a7;
      return (_a7 = t8.hostUpdated) == null ? void 0 : _a7.call(t8);
    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t7)), this.updated(t7);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t7) {
    return true;
  }
  update(t7) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((t8) => this._$EC(t8, this[t8]))), this._$EU();
  }
  updated(t7) {
  }
  firstUpdated(t7) {
  }
};
var _a2;
b.elementStyles = [], b.shadowRootOptions = { mode: "open" }, b[d("elementProperties")] = /* @__PURE__ */ new Map(), b[d("finalized")] = /* @__PURE__ */ new Map(), p == null ? void 0 : p({ ReactiveElement: b }), ((_a2 = a.reactiveElementVersions) != null ? _a2 : a.reactiveElementVersions = []).push("2.0.4");

// node_modules/.pnpm/lit-html@3.1.2/node_modules/lit-html/lit-html.js
var t2 = globalThis;
var i3 = t2.trustedTypes;
var s2 = i3 ? i3.createPolicy("lit-html", { createHTML: (t7) => t7 }) : void 0;
var e3 = "$lit$";
var h2 = `lit$${(Math.random() + "").slice(9)}$`;
var o3 = "?" + h2;
var n3 = `<${o3}>`;
var r3 = document;
var l2 = () => r3.createComment("");
var c3 = (t7) => null === t7 || "object" != typeof t7 && "function" != typeof t7;
var a2 = Array.isArray;
var u2 = (t7) => a2(t7) || "function" == typeof (t7 == null ? void 0 : t7[Symbol.iterator]);
var d2 = "[ 	\n\f\r]";
var f2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var v = /-->/g;
var _ = />/g;
var m = RegExp(`>|${d2}(?:([^\\s"'>=/]+)(${d2}*=${d2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var p2 = /'/g;
var g = /"/g;
var $ = /^(?:script|style|textarea|title)$/i;
var y2 = (t7) => (i6, ...s5) => ({ _$litType$: t7, strings: i6, values: s5 });
var x = y2(1);
var b2 = y2(2);
var w = Symbol.for("lit-noChange");
var T = Symbol.for("lit-nothing");
var A = /* @__PURE__ */ new WeakMap();
var E = r3.createTreeWalker(r3, 129);
function C(t7, i6) {
  if (!Array.isArray(t7) || !t7.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return void 0 !== s2 ? s2.createHTML(i6) : i6;
}
var P = (t7, i6) => {
  const s5 = t7.length - 1, o10 = [];
  let r8, l5 = 2 === i6 ? "<svg>" : "", c4 = f2;
  for (let i7 = 0; i7 < s5; i7++) {
    const s6 = t7[i7];
    let a4, u5, d3 = -1, y3 = 0;
    for (; y3 < s6.length && (c4.lastIndex = y3, u5 = c4.exec(s6), null !== u5); )
      y3 = c4.lastIndex, c4 === f2 ? "!--" === u5[1] ? c4 = v : void 0 !== u5[1] ? c4 = _ : void 0 !== u5[2] ? ($.test(u5[2]) && (r8 = RegExp("</" + u5[2], "g")), c4 = m) : void 0 !== u5[3] && (c4 = m) : c4 === m ? ">" === u5[0] ? (c4 = r8 != null ? r8 : f2, d3 = -1) : void 0 === u5[1] ? d3 = -2 : (d3 = c4.lastIndex - u5[2].length, a4 = u5[1], c4 = void 0 === u5[3] ? m : '"' === u5[3] ? g : p2) : c4 === g || c4 === p2 ? c4 = m : c4 === v || c4 === _ ? c4 = f2 : (c4 = m, r8 = void 0);
    const x2 = c4 === m && t7[i7 + 1].startsWith("/>") ? " " : "";
    l5 += c4 === f2 ? s6 + n3 : d3 >= 0 ? (o10.push(a4), s6.slice(0, d3) + e3 + s6.slice(d3) + h2 + x2) : s6 + h2 + (-2 === d3 ? i7 : x2);
  }
  return [C(t7, l5 + (t7[s5] || "<?>") + (2 === i6 ? "</svg>" : "")), o10];
};
var V = class {
  constructor({ strings: t7, _$litType$: s5 }, n7) {
    let r8;
    this.parts = [];
    let c4 = 0, a4 = 0;
    const u5 = t7.length - 1, d3 = this.parts, [f4, v2] = P(t7, s5);
    if (this.el = V.createElement(f4, n7), E.currentNode = this.el.content, 2 === s5) {
      const t8 = this.el.content.firstChild;
      t8.replaceWith(...t8.childNodes);
    }
    for (; null !== (r8 = E.nextNode()) && d3.length < u5; ) {
      if (1 === r8.nodeType) {
        if (r8.hasAttributes())
          for (const t8 of r8.getAttributeNames())
            if (t8.endsWith(e3)) {
              const i6 = v2[a4++], s6 = r8.getAttribute(t8).split(h2), e11 = /([.?@])?(.*)/.exec(i6);
              d3.push({ type: 1, index: c4, name: e11[2], strings: s6, ctor: "." === e11[1] ? k : "?" === e11[1] ? H : "@" === e11[1] ? I : R }), r8.removeAttribute(t8);
            } else
              t8.startsWith(h2) && (d3.push({ type: 6, index: c4 }), r8.removeAttribute(t8));
        if ($.test(r8.tagName)) {
          const t8 = r8.textContent.split(h2), s6 = t8.length - 1;
          if (s6 > 0) {
            r8.textContent = i3 ? i3.emptyScript : "";
            for (let i6 = 0; i6 < s6; i6++)
              r8.append(t8[i6], l2()), E.nextNode(), d3.push({ type: 2, index: ++c4 });
            r8.append(t8[s6], l2());
          }
        }
      } else if (8 === r8.nodeType)
        if (r8.data === o3)
          d3.push({ type: 2, index: c4 });
        else {
          let t8 = -1;
          for (; -1 !== (t8 = r8.data.indexOf(h2, t8 + 1)); )
            d3.push({ type: 7, index: c4 }), t8 += h2.length - 1;
        }
      c4++;
    }
  }
  static createElement(t7, i6) {
    const s5 = r3.createElement("template");
    return s5.innerHTML = t7, s5;
  }
};
function N(t7, i6, s5 = t7, e11) {
  var _a6, _b2, _c;
  if (i6 === w)
    return i6;
  let h3 = void 0 !== e11 ? (_a6 = s5._$Co) == null ? void 0 : _a6[e11] : s5._$Cl;
  const o10 = c3(i6) ? void 0 : i6._$litDirective$;
  return (h3 == null ? void 0 : h3.constructor) !== o10 && ((_b2 = h3 == null ? void 0 : h3._$AO) == null ? void 0 : _b2.call(h3, false), void 0 === o10 ? h3 = void 0 : (h3 = new o10(t7), h3._$AT(t7, s5, e11)), void 0 !== e11 ? ((_c = s5._$Co) != null ? _c : s5._$Co = [])[e11] = h3 : s5._$Cl = h3), void 0 !== h3 && (i6 = N(t7, h3._$AS(t7, i6.values), h3, e11)), i6;
}
var S2 = class {
  constructor(t7, i6) {
    this._$AV = [], this._$AN = void 0, this._$AD = t7, this._$AM = i6;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t7) {
    var _a6;
    const { el: { content: i6 }, parts: s5 } = this._$AD, e11 = ((_a6 = t7 == null ? void 0 : t7.creationScope) != null ? _a6 : r3).importNode(i6, true);
    E.currentNode = e11;
    let h3 = E.nextNode(), o10 = 0, n7 = 0, l5 = s5[0];
    for (; void 0 !== l5; ) {
      if (o10 === l5.index) {
        let i7;
        2 === l5.type ? i7 = new M(h3, h3.nextSibling, this, t7) : 1 === l5.type ? i7 = new l5.ctor(h3, l5.name, l5.strings, this, t7) : 6 === l5.type && (i7 = new L(h3, this, t7)), this._$AV.push(i7), l5 = s5[++n7];
      }
      o10 !== (l5 == null ? void 0 : l5.index) && (h3 = E.nextNode(), o10++);
    }
    return E.currentNode = r3, e11;
  }
  p(t7) {
    let i6 = 0;
    for (const s5 of this._$AV)
      void 0 !== s5 && (void 0 !== s5.strings ? (s5._$AI(t7, s5, i6), i6 += s5.strings.length - 2) : s5._$AI(t7[i6])), i6++;
  }
};
var M = class {
  get _$AU() {
    var _a6, _b2;
    return (_b2 = (_a6 = this._$AM) == null ? void 0 : _a6._$AU) != null ? _b2 : this._$Cv;
  }
  constructor(t7, i6, s5, e11) {
    var _a6;
    this.type = 2, this._$AH = T, this._$AN = void 0, this._$AA = t7, this._$AB = i6, this._$AM = s5, this.options = e11, this._$Cv = (_a6 = e11 == null ? void 0 : e11.isConnected) != null ? _a6 : true;
  }
  get parentNode() {
    let t7 = this._$AA.parentNode;
    const i6 = this._$AM;
    return void 0 !== i6 && 11 === (t7 == null ? void 0 : t7.nodeType) && (t7 = i6.parentNode), t7;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t7, i6 = this) {
    t7 = N(this, t7, i6), c3(t7) ? t7 === T || null == t7 || "" === t7 ? (this._$AH !== T && this._$AR(), this._$AH = T) : t7 !== this._$AH && t7 !== w && this._(t7) : void 0 !== t7._$litType$ ? this.$(t7) : void 0 !== t7.nodeType ? this.T(t7) : u2(t7) ? this.k(t7) : this._(t7);
  }
  S(t7) {
    return this._$AA.parentNode.insertBefore(t7, this._$AB);
  }
  T(t7) {
    this._$AH !== t7 && (this._$AR(), this._$AH = this.S(t7));
  }
  _(t7) {
    this._$AH !== T && c3(this._$AH) ? this._$AA.nextSibling.data = t7 : this.T(r3.createTextNode(t7)), this._$AH = t7;
  }
  $(t7) {
    var _a6;
    const { values: i6, _$litType$: s5 } = t7, e11 = "number" == typeof s5 ? this._$AC(t7) : (void 0 === s5.el && (s5.el = V.createElement(C(s5.h, s5.h[0]), this.options)), s5);
    if (((_a6 = this._$AH) == null ? void 0 : _a6._$AD) === e11)
      this._$AH.p(i6);
    else {
      const t8 = new S2(e11, this), s6 = t8.u(this.options);
      t8.p(i6), this.T(s6), this._$AH = t8;
    }
  }
  _$AC(t7) {
    let i6 = A.get(t7.strings);
    return void 0 === i6 && A.set(t7.strings, i6 = new V(t7)), i6;
  }
  k(t7) {
    a2(this._$AH) || (this._$AH = [], this._$AR());
    const i6 = this._$AH;
    let s5, e11 = 0;
    for (const h3 of t7)
      e11 === i6.length ? i6.push(s5 = new M(this.S(l2()), this.S(l2()), this, this.options)) : s5 = i6[e11], s5._$AI(h3), e11++;
    e11 < i6.length && (this._$AR(s5 && s5._$AB.nextSibling, e11), i6.length = e11);
  }
  _$AR(t7 = this._$AA.nextSibling, i6) {
    var _a6;
    for ((_a6 = this._$AP) == null ? void 0 : _a6.call(this, false, true, i6); t7 && t7 !== this._$AB; ) {
      const i7 = t7.nextSibling;
      t7.remove(), t7 = i7;
    }
  }
  setConnected(t7) {
    var _a6;
    void 0 === this._$AM && (this._$Cv = t7, (_a6 = this._$AP) == null ? void 0 : _a6.call(this, t7));
  }
};
var R = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t7, i6, s5, e11, h3) {
    this.type = 1, this._$AH = T, this._$AN = void 0, this.element = t7, this.name = i6, this._$AM = e11, this.options = h3, s5.length > 2 || "" !== s5[0] || "" !== s5[1] ? (this._$AH = Array(s5.length - 1).fill(new String()), this.strings = s5) : this._$AH = T;
  }
  _$AI(t7, i6 = this, s5, e11) {
    const h3 = this.strings;
    let o10 = false;
    if (void 0 === h3)
      t7 = N(this, t7, i6, 0), o10 = !c3(t7) || t7 !== this._$AH && t7 !== w, o10 && (this._$AH = t7);
    else {
      const e12 = t7;
      let n7, r8;
      for (t7 = h3[0], n7 = 0; n7 < h3.length - 1; n7++)
        r8 = N(this, e12[s5 + n7], i6, n7), r8 === w && (r8 = this._$AH[n7]), o10 || (o10 = !c3(r8) || r8 !== this._$AH[n7]), r8 === T ? t7 = T : t7 !== T && (t7 += (r8 != null ? r8 : "") + h3[n7 + 1]), this._$AH[n7] = r8;
    }
    o10 && !e11 && this.j(t7);
  }
  j(t7) {
    t7 === T ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t7 != null ? t7 : "");
  }
};
var k = class extends R {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t7) {
    this.element[this.name] = t7 === T ? void 0 : t7;
  }
};
var H = class extends R {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t7) {
    this.element.toggleAttribute(this.name, !!t7 && t7 !== T);
  }
};
var I = class extends R {
  constructor(t7, i6, s5, e11, h3) {
    super(t7, i6, s5, e11, h3), this.type = 5;
  }
  _$AI(t7, i6 = this) {
    var _a6;
    if ((t7 = (_a6 = N(this, t7, i6, 0)) != null ? _a6 : T) === w)
      return;
    const s5 = this._$AH, e11 = t7 === T && s5 !== T || t7.capture !== s5.capture || t7.once !== s5.once || t7.passive !== s5.passive, h3 = t7 !== T && (s5 === T || e11);
    e11 && this.element.removeEventListener(this.name, this, s5), h3 && this.element.addEventListener(this.name, this, t7), this._$AH = t7;
  }
  handleEvent(t7) {
    var _a6, _b2;
    "function" == typeof this._$AH ? this._$AH.call((_b2 = (_a6 = this.options) == null ? void 0 : _a6.host) != null ? _b2 : this.element, t7) : this._$AH.handleEvent(t7);
  }
};
var L = class {
  constructor(t7, i6, s5) {
    this.element = t7, this.type = 6, this._$AN = void 0, this._$AM = i6, this.options = s5;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t7) {
    N(this, t7);
  }
};
var z = { P: e3, A: h2, C: o3, M: 1, L: P, R: S2, D: u2, V: N, I: M, H: R, N: H, U: I, B: k, F: L };
var Z = t2.litHtmlPolyfillSupport;
var _a3;
Z == null ? void 0 : Z(V, M), ((_a3 = t2.litHtmlVersions) != null ? _a3 : t2.litHtmlVersions = []).push("3.1.2");
var j = (t7, i6, s5) => {
  var _a6, _b2;
  const e11 = (_a6 = s5 == null ? void 0 : s5.renderBefore) != null ? _a6 : i6;
  let h3 = e11._$litPart$;
  if (void 0 === h3) {
    const t8 = (_b2 = s5 == null ? void 0 : s5.renderBefore) != null ? _b2 : null;
    e11._$litPart$ = h3 = new M(i6.insertBefore(l2(), t8), t8, void 0, s5 != null ? s5 : {});
  }
  return h3._$AI(t7), h3;
};

// node_modules/.pnpm/lit-element@4.0.4/node_modules/lit-element/lit-element.js
var s3 = class extends b {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var _a6, _b2;
    const t7 = super.createRenderRoot();
    return (_b2 = (_a6 = this.renderOptions).renderBefore) != null ? _b2 : _a6.renderBefore = t7.firstChild, t7;
  }
  update(t7) {
    const i6 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t7), this._$Do = j(i6, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var _a6;
    super.connectedCallback(), (_a6 = this._$Do) == null ? void 0 : _a6.setConnected(true);
  }
  disconnectedCallback() {
    var _a6;
    super.disconnectedCallback(), (_a6 = this._$Do) == null ? void 0 : _a6.setConnected(false);
  }
  render() {
    return w;
  }
};
var _a4;
s3._$litElement$ = true, s3["finalized", "finalized"] = true, (_a4 = globalThis.litElementHydrateSupport) == null ? void 0 : _a4.call(globalThis, { LitElement: s3 });
var r4 = globalThis.litElementPolyfillSupport;
r4 == null ? void 0 : r4({ LitElement: s3 });
var _a5;
((_a5 = globalThis.litElementVersions) != null ? _a5 : globalThis.litElementVersions = []).push("4.0.4");

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7DUCI5S4.js
var spinner_styles_default = i`
  :host {
    --track-width: 2px;
    --track-color: rgb(128 128 128 / 25%);
    --indicator-color: var(--sl-color-primary-600);
    --speed: 2s;

    display: inline-flex;
    width: 1em;
    height: 1em;
    flex: none;
  }

  .spinner {
    flex: 1 1 auto;
    height: 100%;
    width: 100%;
  }

  .spinner__track,
  .spinner__indicator {
    fill: none;
    stroke-width: var(--track-width);
    r: calc(0.5em - var(--track-width) / 2);
    cx: 0.5em;
    cy: 0.5em;
    transform-origin: 50% 50%;
  }

  .spinner__track {
    stroke: var(--track-color);
    transform-origin: 0% 0%;
  }

  .spinner__indicator {
    stroke: var(--indicator-color);
    stroke-linecap: round;
    stroke-dasharray: 150% 75%;
    animation: spin var(--speed) linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
      stroke-dasharray: 0.05em, 3em;
    }

    50% {
      transform: rotate(450deg);
      stroke-dasharray: 1.375em, 1.375em;
    }

    100% {
      transform: rotate(1080deg);
      stroke-dasharray: 0.05em, 3em;
    }
  }
`;

// node_modules/.pnpm/@shoelace-style+localize@3.1.2/node_modules/@shoelace-style/localize/dist/index.js
var connectedElements = /* @__PURE__ */ new Set();
var documentElementObserver = new MutationObserver(update);
var translations = /* @__PURE__ */ new Map();
var documentDirection = document.documentElement.dir || "ltr";
var documentLanguage = document.documentElement.lang || navigator.language;
var fallback;
documentElementObserver.observe(document.documentElement, {
  attributes: true,
  attributeFilter: ["dir", "lang"]
});
function registerTranslation(...translation2) {
  translation2.map((t7) => {
    const code = t7.$code.toLowerCase();
    if (translations.has(code)) {
      translations.set(code, Object.assign(Object.assign({}, translations.get(code)), t7));
    } else {
      translations.set(code, t7);
    }
    if (!fallback) {
      fallback = t7;
    }
  });
  update();
}
function update() {
  documentDirection = document.documentElement.dir || "ltr";
  documentLanguage = document.documentElement.lang || navigator.language;
  [...connectedElements.keys()].map((el) => {
    if (typeof el.requestUpdate === "function") {
      el.requestUpdate();
    }
  });
}
var LocalizeController = class {
  constructor(host) {
    this.host = host;
    this.host.addController(this);
  }
  hostConnected() {
    connectedElements.add(this.host);
  }
  hostDisconnected() {
    connectedElements.delete(this.host);
  }
  dir() {
    return `${this.host.dir || documentDirection}`.toLowerCase();
  }
  lang() {
    return `${this.host.lang || documentLanguage}`.toLowerCase();
  }
  getTranslationData(lang) {
    var _a6, _b2;
    const locale = new Intl.Locale(lang.replace(/_/g, "-"));
    const language = locale === null || locale === void 0 ? void 0 : locale.language.toLowerCase();
    const region = (_b2 = (_a6 = locale === null || locale === void 0 ? void 0 : locale.region) === null || _a6 === void 0 ? void 0 : _a6.toLowerCase()) !== null && _b2 !== void 0 ? _b2 : "";
    const primary = translations.get(`${language}-${region}`);
    const secondary = translations.get(language);
    return { locale, language, region, primary, secondary };
  }
  exists(key, options) {
    var _a6;
    const { primary, secondary } = this.getTranslationData((_a6 = options.lang) !== null && _a6 !== void 0 ? _a6 : this.lang());
    options = Object.assign({ includeFallback: false }, options);
    if (primary && primary[key] || secondary && secondary[key] || options.includeFallback && fallback && fallback[key]) {
      return true;
    }
    return false;
  }
  term(key, ...args) {
    const { primary, secondary } = this.getTranslationData(this.lang());
    let term;
    if (primary && primary[key]) {
      term = primary[key];
    } else if (secondary && secondary[key]) {
      term = secondary[key];
    } else if (fallback && fallback[key]) {
      term = fallback[key];
    } else {
      console.error(`No translation found for: ${String(key)}`);
      return String(key);
    }
    if (typeof term === "function") {
      return term(...args);
    }
    return term;
  }
  date(dateToFormat, options) {
    dateToFormat = new Date(dateToFormat);
    return new Intl.DateTimeFormat(this.lang(), options).format(dateToFormat);
  }
  number(numberToFormat, options) {
    numberToFormat = Number(numberToFormat);
    return isNaN(numberToFormat) ? "" : new Intl.NumberFormat(this.lang(), options).format(numberToFormat);
  }
  relativeTime(value, unit, options) {
    return new Intl.RelativeTimeFormat(this.lang(), options).format(value, unit);
  }
};

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.MAS2SHYD.js
var translation = {
  $code: "en",
  $name: "English",
  $dir: "ltr",
  carousel: "Carousel",
  clearEntry: "Clear entry",
  close: "Close",
  copied: "Copied",
  copy: "Copy",
  currentValue: "Current value",
  error: "Error",
  goToSlide: (slide, count) => `Go to slide ${slide} of ${count}`,
  hidePassword: "Hide password",
  loading: "Loading",
  nextSlide: "Next slide",
  numOptionsSelected: (num) => {
    if (num === 0)
      return "No options selected";
    if (num === 1)
      return "1 option selected";
    return `${num} options selected`;
  },
  previousSlide: "Previous slide",
  progress: "Progress",
  remove: "Remove",
  resize: "Resize",
  scrollToEnd: "Scroll to end",
  scrollToStart: "Scroll to start",
  selectAColorFromTheScreen: "Select a color from the screen",
  showPassword: "Show password",
  slideNum: (slide) => `Slide ${slide}`,
  toggleColorFormat: "Toggle color format"
};
registerTranslation(translation);
var en_default = translation;

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.WLV3FVBR.js
var LocalizeController2 = class extends LocalizeController {
};
registerTranslation(en_default);

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.TUVJKY7S.js
var component_styles_default = i`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.IFDWM6P4.js
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a4, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp2.call(b3, prop))
      __defNormalProp(a4, prop, b3[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b3)) {
      if (__propIsEnum.call(b3, prop))
        __defNormalProp(a4, prop, b3[prop]);
    }
  return a4;
};
var __spreadProps = (a4, b3) => __defProps(a4, __getOwnPropDescs(b3));
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc2(target, key) : target;
  for (var i6 = decorators.length - 1, decorator; i6 >= 0; i6--)
    if (decorator = decorators[i6])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp2(target, key, result);
  return result;
};

// node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/decorators/property.js
var o4 = { attribute: true, type: String, converter: u, reflect: false, hasChanged: f };
var r5 = (t7 = o4, e11, r8) => {
  const { kind: n7, metadata: i6 } = r8;
  let s5 = globalThis.litPropertyMetadata.get(i6);
  if (void 0 === s5 && globalThis.litPropertyMetadata.set(i6, s5 = /* @__PURE__ */ new Map()), s5.set(r8.name, t7), "accessor" === n7) {
    const { name: o10 } = r8;
    return { set(r9) {
      const n8 = e11.get.call(this);
      e11.set.call(this, r9), this.requestUpdate(o10, n8, t7);
    }, init(e12) {
      return void 0 !== e12 && this.P(o10, void 0, t7), e12;
    } };
  }
  if ("setter" === n7) {
    const { name: o10 } = r8;
    return function(r9) {
      const n8 = this[o10];
      e11.call(this, r9), this.requestUpdate(o10, n8, t7);
    };
  }
  throw Error("Unsupported decorator location: " + n7);
};
function n4(t7) {
  return (e11, o10) => "object" == typeof o10 ? r5(t7, e11, o10) : ((t8, e12, o11) => {
    const r8 = e12.hasOwnProperty(o11);
    return e12.constructor.createProperty(o11, r8 ? { ...t8, wrapped: true } : t8), r8 ? Object.getOwnPropertyDescriptor(e12, o11) : void 0;
  })(t7, e11, o10);
}

// node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/decorators/state.js
function r6(r8) {
  return n4({ ...r8, state: true, attribute: false });
}

// node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/decorators/event-options.js
function t3(t7) {
  return (n7, o10) => {
    const c4 = "function" == typeof n7 ? n7 : n7[o10];
    Object.assign(c4, t7);
  };
}

// node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/decorators/base.js
var e4 = (e11, t7, c4) => (c4.configurable = true, c4.enumerable = true, Reflect.decorate && "object" != typeof t7 && Object.defineProperty(e11, t7, c4), c4);

// node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/decorators/query.js
function e5(e11, r8) {
  return (n7, s5, i6) => {
    const o10 = (t7) => {
      var _a6, _b2;
      return (_b2 = (_a6 = t7.renderRoot) == null ? void 0 : _a6.querySelector(e11)) != null ? _b2 : null;
    };
    if (r8) {
      const { get: e12, set: r9 } = "object" == typeof s5 ? n7 : i6 != null ? i6 : (() => {
        const t7 = Symbol();
        return { get() {
          return this[t7];
        }, set(e13) {
          this[t7] = e13;
        } };
      })();
      return e4(n7, s5, { get() {
        let t7 = e12.call(this);
        return void 0 === t7 && (t7 = o10(this), (null !== t7 || this.hasUpdated) && r9.call(this, t7)), t7;
      } });
    }
    return e4(n7, s5, { get() {
      return o10(this);
    } });
  };
}

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.SFSTXCXC.js
var ShoelaceElement = class extends s3 {
  constructor() {
    super();
    Object.entries(this.constructor.dependencies).forEach(([name, component]) => {
      this.constructor.define(name, component);
    });
  }
  emit(name, options) {
    const event = new CustomEvent(name, __spreadValues({
      bubbles: true,
      cancelable: false,
      composed: true,
      detail: {}
    }, options));
    this.dispatchEvent(event);
    return event;
  }
  /* eslint-enable */
  static define(name, elementConstructor = this, options = {}) {
    const currentlyRegisteredConstructor = customElements.get(name);
    if (!currentlyRegisteredConstructor) {
      customElements.define(name, class extends elementConstructor {
      }, options);
      return;
    }
    let newVersion = " (unknown version)";
    let existingVersion = newVersion;
    if ("version" in elementConstructor && elementConstructor.version) {
      newVersion = " v" + elementConstructor.version;
    }
    if ("version" in currentlyRegisteredConstructor && currentlyRegisteredConstructor.version) {
      existingVersion = " v" + currentlyRegisteredConstructor.version;
    }
    if (newVersion && existingVersion && newVersion === existingVersion) {
      return;
    }
    console.warn(
      `Attempted to register <${name}>${newVersion}, but <${name}>${existingVersion} has already been registered.`
    );
  }
};
ShoelaceElement.version = "2.15.0";
ShoelaceElement.dependencies = {};
__decorateClass([
  n4()
], ShoelaceElement.prototype, "dir", 2);
__decorateClass([
  n4()
], ShoelaceElement.prototype, "lang", 2);

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.RADK4UXU.js
var SlSpinner = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
  }
  render() {
    return x`
      <svg part="base" class="spinner" role="progressbar" aria-label=${this.localize.term("loading")}>
        <circle class="spinner__track"></circle>
        <circle class="spinner__indicator"></circle>
      </svg>
    `;
  }
};
SlSpinner.styles = [component_styles_default, spinner_styles_default];

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.KWPBDQ6I.js
var formCollections = /* @__PURE__ */ new WeakMap();
var reportValidityOverloads = /* @__PURE__ */ new WeakMap();
var checkValidityOverloads = /* @__PURE__ */ new WeakMap();
var userInteractedControls = /* @__PURE__ */ new WeakSet();
var interactions = /* @__PURE__ */ new WeakMap();
var FormControlController = class {
  constructor(host, options) {
    this.handleFormData = (event) => {
      const disabled = this.options.disabled(this.host);
      const name = this.options.name(this.host);
      const value = this.options.value(this.host);
      const isButton = this.host.tagName.toLowerCase() === "sl-button";
      if (this.host.isConnected && !disabled && !isButton && typeof name === "string" && name.length > 0 && typeof value !== "undefined") {
        if (Array.isArray(value)) {
          value.forEach((val) => {
            event.formData.append(name, val.toString());
          });
        } else {
          event.formData.append(name, value.toString());
        }
      }
    };
    this.handleFormSubmit = (event) => {
      var _a6;
      const disabled = this.options.disabled(this.host);
      const reportValidity = this.options.reportValidity;
      if (this.form && !this.form.noValidate) {
        (_a6 = formCollections.get(this.form)) == null ? void 0 : _a6.forEach((control) => {
          this.setUserInteracted(control, true);
        });
      }
      if (this.form && !this.form.noValidate && !disabled && !reportValidity(this.host)) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    };
    this.handleFormReset = () => {
      this.options.setValue(this.host, this.options.defaultValue(this.host));
      this.setUserInteracted(this.host, false);
      interactions.set(this.host, []);
    };
    this.handleInteraction = (event) => {
      const emittedEvents = interactions.get(this.host);
      if (!emittedEvents.includes(event.type)) {
        emittedEvents.push(event.type);
      }
      if (emittedEvents.length === this.options.assumeInteractionOn.length) {
        this.setUserInteracted(this.host, true);
      }
    };
    this.checkFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.checkValidity === "function") {
            if (!element.checkValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    this.reportFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.reportValidity === "function") {
            if (!element.reportValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    (this.host = host).addController(this);
    this.options = __spreadValues({
      form: (input) => {
        const formId = input.form;
        if (formId) {
          const root = input.getRootNode();
          const form = root.querySelector(`#${formId}`);
          if (form) {
            return form;
          }
        }
        return input.closest("form");
      },
      name: (input) => input.name,
      value: (input) => input.value,
      defaultValue: (input) => input.defaultValue,
      disabled: (input) => {
        var _a6;
        return (_a6 = input.disabled) != null ? _a6 : false;
      },
      reportValidity: (input) => typeof input.reportValidity === "function" ? input.reportValidity() : true,
      checkValidity: (input) => typeof input.checkValidity === "function" ? input.checkValidity() : true,
      setValue: (input, value) => input.value = value,
      assumeInteractionOn: ["sl-input"]
    }, options);
  }
  hostConnected() {
    const form = this.options.form(this.host);
    if (form) {
      this.attachForm(form);
    }
    interactions.set(this.host, []);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.addEventListener(event, this.handleInteraction);
    });
  }
  hostDisconnected() {
    this.detachForm();
    interactions.delete(this.host);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.removeEventListener(event, this.handleInteraction);
    });
  }
  hostUpdated() {
    const form = this.options.form(this.host);
    if (!form) {
      this.detachForm();
    }
    if (form && this.form !== form) {
      this.detachForm();
      this.attachForm(form);
    }
    if (this.host.hasUpdated) {
      this.setValidity(this.host.validity.valid);
    }
  }
  attachForm(form) {
    if (form) {
      this.form = form;
      if (formCollections.has(this.form)) {
        formCollections.get(this.form).add(this.host);
      } else {
        formCollections.set(this.form, /* @__PURE__ */ new Set([this.host]));
      }
      this.form.addEventListener("formdata", this.handleFormData);
      this.form.addEventListener("submit", this.handleFormSubmit);
      this.form.addEventListener("reset", this.handleFormReset);
      if (!reportValidityOverloads.has(this.form)) {
        reportValidityOverloads.set(this.form, this.form.reportValidity);
        this.form.reportValidity = () => this.reportFormValidity();
      }
      if (!checkValidityOverloads.has(this.form)) {
        checkValidityOverloads.set(this.form, this.form.checkValidity);
        this.form.checkValidity = () => this.checkFormValidity();
      }
    } else {
      this.form = void 0;
    }
  }
  detachForm() {
    if (!this.form)
      return;
    const formCollection = formCollections.get(this.form);
    if (!formCollection) {
      return;
    }
    formCollection.delete(this.host);
    if (formCollection.size <= 0) {
      this.form.removeEventListener("formdata", this.handleFormData);
      this.form.removeEventListener("submit", this.handleFormSubmit);
      this.form.removeEventListener("reset", this.handleFormReset);
      if (reportValidityOverloads.has(this.form)) {
        this.form.reportValidity = reportValidityOverloads.get(this.form);
        reportValidityOverloads.delete(this.form);
      }
      if (checkValidityOverloads.has(this.form)) {
        this.form.checkValidity = checkValidityOverloads.get(this.form);
        checkValidityOverloads.delete(this.form);
      }
      this.form = void 0;
    }
  }
  setUserInteracted(el, hasInteracted) {
    if (hasInteracted) {
      userInteractedControls.add(el);
    } else {
      userInteractedControls.delete(el);
    }
    el.requestUpdate();
  }
  doAction(type, submitter) {
    if (this.form) {
      const button = document.createElement("button");
      button.type = type;
      button.style.position = "absolute";
      button.style.width = "0";
      button.style.height = "0";
      button.style.clipPath = "inset(50%)";
      button.style.overflow = "hidden";
      button.style.whiteSpace = "nowrap";
      if (submitter) {
        button.name = submitter.name;
        button.value = submitter.value;
        ["formaction", "formenctype", "formmethod", "formnovalidate", "formtarget"].forEach((attr) => {
          if (submitter.hasAttribute(attr)) {
            button.setAttribute(attr, submitter.getAttribute(attr));
          }
        });
      }
      this.form.append(button);
      button.click();
      button.remove();
    }
  }
  /** Returns the associated `<form>` element, if one exists. */
  getForm() {
    var _a6;
    return (_a6 = this.form) != null ? _a6 : null;
  }
  /** Resets the form, restoring all the control to their default value */
  reset(submitter) {
    this.doAction("reset", submitter);
  }
  /** Submits the form, triggering validation and form data injection. */
  submit(submitter) {
    this.doAction("submit", submitter);
  }
  /**
   * Synchronously sets the form control's validity. Call this when you know the future validity but need to update
   * the host element immediately, i.e. before Lit updates the component in the next update.
   */
  setValidity(isValid) {
    const host = this.host;
    const hasInteracted = Boolean(userInteractedControls.has(host));
    const required = Boolean(host.required);
    host.toggleAttribute("data-required", required);
    host.toggleAttribute("data-optional", !required);
    host.toggleAttribute("data-invalid", !isValid);
    host.toggleAttribute("data-valid", isValid);
    host.toggleAttribute("data-user-invalid", !isValid && hasInteracted);
    host.toggleAttribute("data-user-valid", isValid && hasInteracted);
  }
  /**
   * Updates the form control's validity based on the current value of `host.validity.valid`. Call this when anything
   * that affects constraint validation changes so the component receives the correct validity states.
   */
  updateValidity() {
    const host = this.host;
    this.setValidity(host.validity.valid);
  }
  /**
   * Dispatches a non-bubbling, cancelable custom event of type `sl-invalid`.
   * If the `sl-invalid` event will be cancelled then the original `invalid`
   * event (which may have been passed as argument) will also be cancelled.
   * If no original `invalid` event has been passed then the `sl-invalid`
   * event will be cancelled before being dispatched.
   */
  emitInvalidEvent(originalInvalidEvent) {
    const slInvalidEvent = new CustomEvent("sl-invalid", {
      bubbles: false,
      composed: false,
      cancelable: true,
      detail: {}
    });
    if (!originalInvalidEvent) {
      slInvalidEvent.preventDefault();
    }
    if (!this.host.dispatchEvent(slInvalidEvent)) {
      originalInvalidEvent == null ? void 0 : originalInvalidEvent.preventDefault();
    }
  }
};
var validValidityState = Object.freeze({
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valid: true,
  valueMissing: false
});
var valueMissingValidityState = Object.freeze(__spreadProps(__spreadValues({}, validValidityState), {
  valid: false,
  valueMissing: true
}));
var customErrorValidityState = Object.freeze(__spreadProps(__spreadValues({}, validValidityState), {
  valid: false,
  customError: true
}));

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.HLDU3ZPH.js
var button_styles_default = i`
  :host {
    display: inline-block;
    position: relative;
    width: auto;
    cursor: pointer;
  }

  .button {
    display: inline-flex;
    align-items: stretch;
    justify-content: center;
    width: 100%;
    border-style: solid;
    border-width: var(--sl-input-border-width);
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-font-weight-semibold);
    text-decoration: none;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    vertical-align: middle;
    padding: 0;
    transition:
      var(--sl-transition-x-fast) background-color,
      var(--sl-transition-x-fast) color,
      var(--sl-transition-x-fast) border,
      var(--sl-transition-x-fast) box-shadow;
    cursor: inherit;
  }

  .button::-moz-focus-inner {
    border: 0;
  }

  .button:focus {
    outline: none;
  }

  .button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When disabled, prevent mouse events from bubbling up from children */
  .button--disabled * {
    pointer-events: none;
  }

  .button__prefix,
  .button__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    pointer-events: none;
  }

  .button__label {
    display: inline-block;
  }

  .button__label::slotted(sl-icon) {
    vertical-align: -2px;
  }

  /*
   * Standard buttons
   */

  /* Default */
  .button--standard.button--default {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--standard.button--default:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-300);
    color: var(--sl-color-primary-700);
  }

  .button--standard.button--default:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-100);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
  }

  /* Primary */
  .button--standard.button--primary {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--standard.button--success {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-500);
    border-color: var(--sl-color-success-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:active:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--standard.button--neutral {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:active:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--standard.button--warning {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }
  .button--standard.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--warning:active:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--standard.button--danger {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:active:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Outline buttons
   */

  .button--outline {
    background: none;
    border: solid 1px;
  }

  /* Default */
  .button--outline.button--default {
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--outline.button--default:hover:not(.button--disabled),
  .button--outline.button--default.button--checked:not(.button--disabled) {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--default:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Primary */
  .button--outline.button--primary {
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-primary-600);
  }

  .button--outline.button--primary:hover:not(.button--disabled),
  .button--outline.button--primary.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--primary:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--outline.button--success {
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-success-600);
  }

  .button--outline.button--success:hover:not(.button--disabled),
  .button--outline.button--success.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--success:active:not(.button--disabled) {
    border-color: var(--sl-color-success-700);
    background-color: var(--sl-color-success-700);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--outline.button--neutral {
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-600);
  }

  .button--outline.button--neutral:hover:not(.button--disabled),
  .button--outline.button--neutral.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--neutral:active:not(.button--disabled) {
    border-color: var(--sl-color-neutral-700);
    background-color: var(--sl-color-neutral-700);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--outline.button--warning {
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-warning-600);
  }

  .button--outline.button--warning:hover:not(.button--disabled),
  .button--outline.button--warning.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--warning:active:not(.button--disabled) {
    border-color: var(--sl-color-warning-700);
    background-color: var(--sl-color-warning-700);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--outline.button--danger {
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-danger-600);
  }

  .button--outline.button--danger:hover:not(.button--disabled),
  .button--outline.button--danger.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--danger:active:not(.button--disabled) {
    border-color: var(--sl-color-danger-700);
    background-color: var(--sl-color-danger-700);
    color: var(--sl-color-neutral-0);
  }

  @media (forced-colors: active) {
    .button.button--outline.button--checked:not(.button--disabled) {
      outline: solid 2px transparent;
    }
  }

  /*
   * Text buttons
   */

  .button--text {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-600);
  }

  .button--text:hover:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:focus-visible:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:active:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-700);
  }

  /*
   * Size modifiers
   */

  .button--small {
    height: auto;
    min-height: var(--sl-input-height-small);
    font-size: var(--sl-button-font-size-small);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
  }

  .button--medium {
    height: auto;
    min-height: var(--sl-input-height-medium);
    font-size: var(--sl-button-font-size-medium);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
  }

  .button--large {
    height: auto;
    min-height: var(--sl-input-height-large);
    font-size: var(--sl-button-font-size-large);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
  }

  /*
   * Pill modifier
   */

  .button--pill.button--small {
    border-radius: var(--sl-input-height-small);
  }

  .button--pill.button--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .button--pill.button--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Circle modifier
   */

  .button--circle {
    padding-left: 0;
    padding-right: 0;
  }

  .button--circle.button--small {
    width: var(--sl-input-height-small);
    border-radius: 50%;
  }

  .button--circle.button--medium {
    width: var(--sl-input-height-medium);
    border-radius: 50%;
  }

  .button--circle.button--large {
    width: var(--sl-input-height-large);
    border-radius: 50%;
  }

  .button--circle .button__prefix,
  .button--circle .button__suffix,
  .button--circle .button__caret {
    display: none;
  }

  /*
   * Caret modifier
   */

  .button--caret .button__suffix {
    display: none;
  }

  .button--caret .button__caret {
    height: auto;
  }

  /*
   * Loading modifier
   */

  .button--loading {
    position: relative;
    cursor: wait;
  }

  .button--loading .button__prefix,
  .button--loading .button__label,
  .button--loading .button__suffix,
  .button--loading .button__caret {
    visibility: hidden;
  }

  .button--loading sl-spinner {
    --indicator-color: currentColor;
    position: absolute;
    font-size: 1em;
    height: 1em;
    width: 1em;
    top: calc(50% - 0.5em);
    left: calc(50% - 0.5em);
  }

  /*
   * Badges
   */

  .button ::slotted(sl-badge) {
    position: absolute;
    top: 0;
    right: 0;
    translate: 50% -50%;
    pointer-events: none;
  }

  .button--rtl ::slotted(sl-badge) {
    right: auto;
    left: 0;
    translate: -50% -50%;
  }

  /*
   * Button spacing
   */

  .button--has-label.button--small .button__label {
    padding: 0 var(--sl-spacing-small);
  }

  .button--has-label.button--medium .button__label {
    padding: 0 var(--sl-spacing-medium);
  }

  .button--has-label.button--large .button__label {
    padding: 0 var(--sl-spacing-large);
  }

  .button--has-prefix.button--small {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--small .button__label {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--medium {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--medium .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-suffix.button--small,
  .button--caret.button--small {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--small .button__label,
  .button--caret.button--small .button__label {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--medium,
  .button--caret.button--medium {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--medium .button__label,
  .button--caret.button--medium .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large,
  .button--caret.button--large {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large .button__label,
  .button--caret.button--large .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  /*
   * Button groups support a variety of button types (e.g. buttons with tooltips, buttons as dropdown triggers, etc.).
   * This means buttons aren't always direct descendants of the button group, thus we can't target them with the
   * ::slotted selector. To work around this, the button group component does some magic to add these special classes to
   * buttons and we style them here instead.
   */

  :host([data-sl-button-group__button--first]:not([data-sl-button-group__button--last])) .button {
    border-start-end-radius: 0;
    border-end-end-radius: 0;
  }

  :host([data-sl-button-group__button--inner]) .button {
    border-radius: 0;
  }

  :host([data-sl-button-group__button--last]:not([data-sl-button-group__button--first])) .button {
    border-start-start-radius: 0;
    border-end-start-radius: 0;
  }

  /* All except the first */
  :host([data-sl-button-group__button]:not([data-sl-button-group__button--first])) {
    margin-inline-start: calc(-1 * var(--sl-input-border-width));
  }

  /* Add a visual separator between solid buttons */
  :host(
      [data-sl-button-group__button]:not(
          [data-sl-button-group__button--first],
          [data-sl-button-group__button--radio],
          [variant='default']
        ):not(:hover)
    )
    .button:after {
    content: '';
    position: absolute;
    top: 0;
    inset-inline-start: 0;
    bottom: 0;
    border-left: solid 1px rgb(128 128 128 / 33%);
    mix-blend-mode: multiply;
  }

  /* Bump hovered, focused, and checked buttons up so their focus ring isn't clipped */
  :host([data-sl-button-group__button--hover]) {
    z-index: 1;
  }

  /* Focus and checked are always on top */
  :host([data-sl-button-group__button--focus]),
  :host([data-sl-button-group__button[checked]]) {
    z-index: 2;
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.NYIIDP5N.js
var HasSlotController = class {
  constructor(host, ...slotNames) {
    this.slotNames = [];
    this.handleSlotChange = (event) => {
      const slot = event.target;
      if (this.slotNames.includes("[default]") && !slot.name || slot.name && this.slotNames.includes(slot.name)) {
        this.host.requestUpdate();
      }
    };
    (this.host = host).addController(this);
    this.slotNames = slotNames;
  }
  hasDefaultSlot() {
    return [...this.host.childNodes].some((node) => {
      if (node.nodeType === node.TEXT_NODE && node.textContent.trim() !== "") {
        return true;
      }
      if (node.nodeType === node.ELEMENT_NODE) {
        const el = node;
        const tagName = el.tagName.toLowerCase();
        if (tagName === "sl-visually-hidden") {
          return false;
        }
        if (!el.hasAttribute("slot")) {
          return true;
        }
      }
      return false;
    });
  }
  hasNamedSlot(name) {
    return this.host.querySelector(`:scope > [slot="${name}"]`) !== null;
  }
  test(slotName) {
    return slotName === "[default]" ? this.hasDefaultSlot() : this.hasNamedSlot(slotName);
  }
  hostConnected() {
    this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
  }
  hostDisconnected() {
    this.host.shadowRoot.removeEventListener("slotchange", this.handleSlotChange);
  }
};

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3Y6SB6QS.js
var basePath = "";
function setBasePath(path) {
  basePath = path;
}
function getBasePath(subpath = "") {
  if (!basePath) {
    const scripts = [...document.getElementsByTagName("script")];
    const configScript = scripts.find((script) => script.hasAttribute("data-shoelace"));
    if (configScript) {
      setBasePath(configScript.getAttribute("data-shoelace"));
    } else {
      const fallbackScript = scripts.find((s5) => {
        return /shoelace(\.min)?\.js($|\?)/.test(s5.src) || /shoelace-autoloader(\.min)?\.js($|\?)/.test(s5.src);
      });
      let path = "";
      if (fallbackScript) {
        path = fallbackScript.getAttribute("src");
      }
      setBasePath(path.split("/").slice(0, -1).join("/"));
    }
  }
  return basePath.replace(/\/$/, "") + (subpath ? `/${subpath.replace(/^\//, "")}` : ``);
}

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.P7ZG6EMR.js
var library = {
  name: "default",
  resolver: (name) => getBasePath(`assets/icons/${name}.svg`)
};
var library_default_default = library;

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3TFKS637.js
var icons = {
  caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
  check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  copy: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-copy" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6ZM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1H2Z"/>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
  indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="3.42857143"></circle>
        </g>
      </g>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `
};
var systemLibrary = {
  name: "system",
  resolver: (name) => {
    if (name in icons) {
      return `data:image/svg+xml,${encodeURIComponent(icons[name])}`;
    }
    return "";
  }
};
var library_system_default = systemLibrary;

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ZL53POKZ.js
var registry = [library_default_default, library_system_default];
var watchedIcons = [];
function watchIcon(icon) {
  watchedIcons.push(icon);
}
function unwatchIcon(icon) {
  watchedIcons = watchedIcons.filter((el) => el !== icon);
}
function getIconLibrary(name) {
  return registry.find((lib) => lib.name === name);
}

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.QLXRCYS4.js
var icon_styles_default = i`
  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2FB5TK5H.js
function watch(propertyName, options) {
  const resolvedOptions = __spreadValues({
    waitUntilFirstUpdate: false
  }, options);
  return (proto, decoratedFnName) => {
    const { update: update2 } = proto;
    const watchedProperties = Array.isArray(propertyName) ? propertyName : [propertyName];
    proto.update = function(changedProps) {
      watchedProperties.forEach((property) => {
        const key = property;
        if (changedProps.has(key)) {
          const oldValue = changedProps.get(key);
          const newValue = this[key];
          if (oldValue !== newValue) {
            if (!resolvedOptions.waitUntilFirstUpdate || this.hasUpdated) {
              this[decoratedFnName](oldValue, newValue);
            }
          }
        }
      });
      update2.call(this, changedProps);
    };
  };
}

// node_modules/.pnpm/lit-html@3.1.2/node_modules/lit-html/directive-helpers.js
var { I: t4 } = z;
var e6 = (o10, t7) => void 0 === t7 ? void 0 !== (o10 == null ? void 0 : o10._$litType$) : (o10 == null ? void 0 : o10._$litType$) === t7;
var f3 = (o10) => void 0 === o10.strings;
var u3 = {};
var m2 = (o10, t7 = u3) => o10._$AH = t7;

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.H33C3MRM.js
var CACHEABLE_ERROR = Symbol();
var RETRYABLE_ERROR = Symbol();
var parser;
var iconCache = /* @__PURE__ */ new Map();
var SlIcon = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.initialRender = false;
    this.svg = null;
    this.label = "";
    this.library = "default";
  }
  /** Given a URL, this function returns the resulting SVG element or an appropriate error symbol. */
  async resolveIcon(url, library2) {
    var _a6;
    let fileData;
    if (library2 == null ? void 0 : library2.spriteSheet) {
      this.svg = x`<svg part="svg">
        <use part="use" href="${url}"></use>
      </svg>`;
      await this.updateComplete;
      const svg = this.shadowRoot.querySelector("[part='svg']");
      if (typeof library2.mutator === "function") {
        library2.mutator(svg);
      }
      return this.svg;
    }
    try {
      fileData = await fetch(url, { mode: "cors" });
      if (!fileData.ok)
        return fileData.status === 410 ? CACHEABLE_ERROR : RETRYABLE_ERROR;
    } catch (e11) {
      return RETRYABLE_ERROR;
    }
    try {
      const div = document.createElement("div");
      div.innerHTML = await fileData.text();
      const svg = div.firstElementChild;
      if (((_a6 = svg == null ? void 0 : svg.tagName) == null ? void 0 : _a6.toLowerCase()) !== "svg")
        return CACHEABLE_ERROR;
      if (!parser)
        parser = new DOMParser();
      const doc = parser.parseFromString(svg.outerHTML, "text/html");
      const svgEl = doc.body.querySelector("svg");
      if (!svgEl)
        return CACHEABLE_ERROR;
      svgEl.part.add("svg");
      return document.adoptNode(svgEl);
    } catch (e11) {
      return CACHEABLE_ERROR;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    watchIcon(this);
  }
  firstUpdated() {
    this.initialRender = true;
    this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    unwatchIcon(this);
  }
  getIconSource() {
    const library2 = getIconLibrary(this.library);
    if (this.name && library2) {
      return {
        url: library2.resolver(this.name),
        fromLibrary: true
      };
    }
    return {
      url: this.src,
      fromLibrary: false
    };
  }
  handleLabelChange() {
    const hasLabel = typeof this.label === "string" && this.label.length > 0;
    if (hasLabel) {
      this.setAttribute("role", "img");
      this.setAttribute("aria-label", this.label);
      this.removeAttribute("aria-hidden");
    } else {
      this.removeAttribute("role");
      this.removeAttribute("aria-label");
      this.setAttribute("aria-hidden", "true");
    }
  }
  async setIcon() {
    var _a6;
    const { url, fromLibrary } = this.getIconSource();
    const library2 = fromLibrary ? getIconLibrary(this.library) : void 0;
    if (!url) {
      this.svg = null;
      return;
    }
    let iconResolver = iconCache.get(url);
    if (!iconResolver) {
      iconResolver = this.resolveIcon(url, library2);
      iconCache.set(url, iconResolver);
    }
    if (!this.initialRender) {
      return;
    }
    const svg = await iconResolver;
    if (svg === RETRYABLE_ERROR) {
      iconCache.delete(url);
    }
    if (url !== this.getIconSource().url) {
      return;
    }
    if (e6(svg)) {
      this.svg = svg;
      return;
    }
    switch (svg) {
      case RETRYABLE_ERROR:
      case CACHEABLE_ERROR:
        this.svg = null;
        this.emit("sl-error");
        break;
      default:
        this.svg = svg.cloneNode(true);
        (_a6 = library2 == null ? void 0 : library2.mutator) == null ? void 0 : _a6.call(library2, this.svg);
        this.emit("sl-load");
    }
  }
  render() {
    return this.svg;
  }
};
SlIcon.styles = [component_styles_default, icon_styles_default];
__decorateClass([
  r6()
], SlIcon.prototype, "svg", 2);
__decorateClass([
  n4({ reflect: true })
], SlIcon.prototype, "name", 2);
__decorateClass([
  n4()
], SlIcon.prototype, "src", 2);
__decorateClass([
  n4()
], SlIcon.prototype, "label", 2);
__decorateClass([
  n4({ reflect: true })
], SlIcon.prototype, "library", 2);
__decorateClass([
  watch("label")
], SlIcon.prototype, "handleLabelChange", 1);
__decorateClass([
  watch(["name", "src", "library"])
], SlIcon.prototype, "setIcon", 1);

// node_modules/.pnpm/lit-html@3.1.2/node_modules/lit-html/directive.js
var t5 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var e7 = (t7) => (...e11) => ({ _$litDirective$: t7, values: e11 });
var i4 = class {
  constructor(t7) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t7, e11, i6) {
    this._$Ct = t7, this._$AM = e11, this._$Ci = i6;
  }
  _$AS(t7, e11) {
    return this.update(t7, e11);
  }
  update(t7, e11) {
    return this.render(...e11);
  }
};

// node_modules/.pnpm/lit-html@3.1.2/node_modules/lit-html/directives/class-map.js
var e8 = e7(class extends i4 {
  constructor(t7) {
    var _a6;
    if (super(t7), t7.type !== t5.ATTRIBUTE || "class" !== t7.name || ((_a6 = t7.strings) == null ? void 0 : _a6.length) > 2)
      throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t7) {
    return " " + Object.keys(t7).filter((s5) => t7[s5]).join(" ") + " ";
  }
  update(s5, [i6]) {
    var _a6, _b2;
    if (void 0 === this.st) {
      this.st = /* @__PURE__ */ new Set(), void 0 !== s5.strings && (this.nt = new Set(s5.strings.join(" ").split(/\s/).filter((t7) => "" !== t7)));
      for (const t7 in i6)
        i6[t7] && !((_a6 = this.nt) == null ? void 0 : _a6.has(t7)) && this.st.add(t7);
      return this.render(i6);
    }
    const r8 = s5.element.classList;
    for (const t7 of this.st)
      t7 in i6 || (r8.remove(t7), this.st.delete(t7));
    for (const t7 in i6) {
      const s6 = !!i6[t7];
      s6 === this.st.has(t7) || ((_b2 = this.nt) == null ? void 0 : _b2.has(t7)) || (s6 ? (r8.add(t7), this.st.add(t7)) : (r8.remove(t7), this.st.delete(t7)));
    }
    return w;
  }
});

// node_modules/.pnpm/lit-html@3.1.2/node_modules/lit-html/static.js
var e9 = Symbol.for("");
var o5 = (t7) => {
  if ((t7 == null ? void 0 : t7.r) === e9)
    return t7 == null ? void 0 : t7._$litStatic$;
};
var s4 = (t7, ...r8) => ({ _$litStatic$: r8.reduce((r9, e11, o10) => r9 + ((t8) => {
  if (void 0 !== t8._$litStatic$)
    return t8._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t8}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(e11) + t7[o10 + 1], t7[0]), r: e9 });
var a3 = /* @__PURE__ */ new Map();
var l3 = (t7) => (r8, ...e11) => {
  const i6 = e11.length;
  let s5, l5;
  const n7 = [], u5 = [];
  let c4, $2 = 0, f4 = false;
  for (; $2 < i6; ) {
    for (c4 = r8[$2]; $2 < i6 && void 0 !== (l5 = e11[$2], s5 = o5(l5)); )
      c4 += s5 + r8[++$2], f4 = true;
    $2 !== i6 && u5.push(l5), n7.push(c4), $2++;
  }
  if ($2 === i6 && n7.push(r8[i6]), f4) {
    const t8 = n7.join("$$lit$$");
    void 0 === (r8 = a3.get(t8)) && (n7.raw = n7, a3.set(t8, r8 = n7)), e11 = u5;
  }
  return t7(r8, ...e11);
};
var n5 = l3(x);
var u4 = l3(b2);

// node_modules/.pnpm/lit-html@3.1.2/node_modules/lit-html/directives/if-defined.js
var o6 = (o10) => o10 != null ? o10 : T;

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.5SUGJ4EB.js
var SlButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["click"]
    });
    this.hasSlotController = new HasSlotController(this, "[default]", "prefix", "suffix");
    this.localize = new LocalizeController2(this);
    this.hasFocus = false;
    this.invalid = false;
    this.title = "";
    this.variant = "default";
    this.size = "medium";
    this.caret = false;
    this.disabled = false;
    this.loading = false;
    this.outline = false;
    this.pill = false;
    this.circle = false;
    this.type = "button";
    this.name = "";
    this.value = "";
    this.href = "";
    this.rel = "noreferrer noopener";
  }
  /** Gets the validity state object */
  get validity() {
    if (this.isButton()) {
      return this.button.validity;
    }
    return validValidityState;
  }
  /** Gets the validation message */
  get validationMessage() {
    if (this.isButton()) {
      return this.button.validationMessage;
    }
    return "";
  }
  firstUpdated() {
    if (this.isButton()) {
      this.formControlController.updateValidity();
    }
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick() {
    if (this.type === "submit") {
      this.formControlController.submit(this);
    }
    if (this.type === "reset") {
      this.formControlController.reset(this);
    }
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  isButton() {
    return this.href ? false : true;
  }
  isLink() {
    return this.href ? true : false;
  }
  handleDisabledChange() {
    if (this.isButton()) {
      this.formControlController.setValidity(this.disabled);
    }
  }
  /** Simulates a click on the button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the button. */
  blur() {
    this.button.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    if (this.isButton()) {
      return this.button.checkValidity();
    }
    return true;
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    if (this.isButton()) {
      return this.button.reportValidity();
    }
    return true;
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    if (this.isButton()) {
      this.button.setCustomValidity(message);
      this.formControlController.updateValidity();
    }
  }
  render() {
    const isLink = this.isLink();
    const tag = isLink ? s4`a` : s4`button`;
    return n5`
      <${tag}
        part="base"
        class=${e8({
      button: true,
      "button--default": this.variant === "default",
      "button--primary": this.variant === "primary",
      "button--success": this.variant === "success",
      "button--neutral": this.variant === "neutral",
      "button--warning": this.variant === "warning",
      "button--danger": this.variant === "danger",
      "button--text": this.variant === "text",
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--caret": this.caret,
      "button--circle": this.circle,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--loading": this.loading,
      "button--standard": !this.outline,
      "button--outline": this.outline,
      "button--pill": this.pill,
      "button--rtl": this.localize.dir() === "rtl",
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
        ?disabled=${o6(isLink ? void 0 : this.disabled)}
        type=${o6(isLink ? void 0 : this.type)}
        title=${this.title}
        name=${o6(isLink ? void 0 : this.name)}
        value=${o6(isLink ? void 0 : this.value)}
        href=${o6(isLink ? this.href : void 0)}
        target=${o6(isLink ? this.target : void 0)}
        download=${o6(isLink ? this.download : void 0)}
        rel=${o6(isLink ? this.rel : void 0)}
        role=${o6(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @invalid=${this.isButton() ? this.handleInvalid : null}
        @click=${this.handleClick}
      >
        <slot name="prefix" part="prefix" class="button__prefix"></slot>
        <slot part="label" class="button__label"></slot>
        <slot name="suffix" part="suffix" class="button__suffix"></slot>
        ${this.caret ? n5` <sl-icon part="caret" class="button__caret" library="system" name="caret"></sl-icon> ` : ""}
        ${this.loading ? n5`<sl-spinner part="spinner"></sl-spinner>` : ""}
      </${tag}>
    `;
  }
};
SlButton.styles = [component_styles_default, button_styles_default];
SlButton.dependencies = {
  "sl-icon": SlIcon,
  "sl-spinner": SlSpinner
};
__decorateClass([
  e5(".button")
], SlButton.prototype, "button", 2);
__decorateClass([
  r6()
], SlButton.prototype, "hasFocus", 2);
__decorateClass([
  r6()
], SlButton.prototype, "invalid", 2);
__decorateClass([
  n4()
], SlButton.prototype, "title", 2);
__decorateClass([
  n4({ reflect: true })
], SlButton.prototype, "variant", 2);
__decorateClass([
  n4({ reflect: true })
], SlButton.prototype, "size", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "caret", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "disabled", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "loading", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "outline", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "pill", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "circle", 2);
__decorateClass([
  n4()
], SlButton.prototype, "type", 2);
__decorateClass([
  n4()
], SlButton.prototype, "name", 2);
__decorateClass([
  n4()
], SlButton.prototype, "value", 2);
__decorateClass([
  n4()
], SlButton.prototype, "href", 2);
__decorateClass([
  n4()
], SlButton.prototype, "target", 2);
__decorateClass([
  n4()
], SlButton.prototype, "rel", 2);
__decorateClass([
  n4()
], SlButton.prototype, "download", 2);
__decorateClass([
  n4()
], SlButton.prototype, "form", 2);
__decorateClass([
  n4({ attribute: "formaction" })
], SlButton.prototype, "formAction", 2);
__decorateClass([
  n4({ attribute: "formenctype" })
], SlButton.prototype, "formEnctype", 2);
__decorateClass([
  n4({ attribute: "formmethod" })
], SlButton.prototype, "formMethod", 2);
__decorateClass([
  n4({ attribute: "formnovalidate", type: Boolean })
], SlButton.prototype, "formNoValidate", 2);
__decorateClass([
  n4({ attribute: "formtarget" })
], SlButton.prototype, "formTarget", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlButton.prototype, "handleDisabledChange", 1);

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7XIC3PQE.js
SlButton.define("sl-button");

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LXP7GVU3.js
var dropdown_styles_default = i`
  :host {
    display: inline-block;
  }

  .dropdown::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .dropdown[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .dropdown[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .dropdown[data-current-placement^='left']::part(popup) {
    transform-origin: right;
  }

  .dropdown[data-current-placement^='right']::part(popup) {
    transform-origin: left;
  }

  .dropdown__trigger {
    display: block;
  }

  .dropdown__panel {
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    border-radius: var(--sl-border-radius-medium);
    pointer-events: none;
  }

  .dropdown--open .dropdown__panel {
    display: block;
    pointer-events: all;
  }

  /* When users slot a menu, make sure it conforms to the popup's auto-size */
  ::slotted(sl-menu) {
    max-width: var(--auto-size-available-width) !important;
    max-height: var(--auto-size-available-height) !important;
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LXDTFLWU.js
var computedStyleMap = /* @__PURE__ */ new WeakMap();
function getCachedComputedStyle(el) {
  let computedStyle = computedStyleMap.get(el);
  if (!computedStyle) {
    computedStyle = window.getComputedStyle(el, null);
    computedStyleMap.set(el, computedStyle);
  }
  return computedStyle;
}
function isVisible(el) {
  if (typeof el.checkVisibility === "function") {
    return el.checkVisibility({ checkOpacity: false, checkVisibilityCSS: true });
  }
  const computedStyle = getCachedComputedStyle(el);
  return computedStyle.visibility !== "hidden" && computedStyle.display !== "none";
}
function isOverflowingAndTabbable(el) {
  const computedStyle = getCachedComputedStyle(el);
  const { overflowY, overflowX } = computedStyle;
  if (overflowY === "scroll" || overflowX === "scroll") {
    return true;
  }
  if (overflowY !== "auto" || overflowX !== "auto") {
    return false;
  }
  const isOverflowingY = el.scrollHeight > el.clientHeight;
  if (isOverflowingY && overflowY === "auto") {
    return true;
  }
  const isOverflowingX = el.scrollWidth > el.clientWidth;
  if (isOverflowingX && overflowX === "auto") {
    return true;
  }
  return false;
}
function isTabbable(el) {
  const tag = el.tagName.toLowerCase();
  const tabindex = Number(el.getAttribute("tabindex"));
  const hasTabindex = el.hasAttribute("tabindex");
  if (hasTabindex && (isNaN(tabindex) || tabindex <= -1)) {
    return false;
  }
  if (el.hasAttribute("disabled")) {
    return false;
  }
  if (el.closest("[inert]")) {
    return false;
  }
  if (tag === "input" && el.getAttribute("type") === "radio" && !el.hasAttribute("checked")) {
    return false;
  }
  if (!isVisible(el)) {
    return false;
  }
  if ((tag === "audio" || tag === "video") && el.hasAttribute("controls")) {
    return true;
  }
  if (el.hasAttribute("tabindex")) {
    return true;
  }
  if (el.hasAttribute("contenteditable") && el.getAttribute("contenteditable") !== "false") {
    return true;
  }
  const isNativelyTabbable = [
    "button",
    "input",
    "select",
    "textarea",
    "a",
    "audio",
    "video",
    "summary",
    "iframe"
  ].includes(tag);
  if (isNativelyTabbable) {
    return true;
  }
  return isOverflowingAndTabbable(el);
}
function getTabbableBoundary(root) {
  var _a6, _b2;
  const tabbableElements = getTabbableElements(root);
  const start = (_a6 = tabbableElements[0]) != null ? _a6 : null;
  const end = (_b2 = tabbableElements[tabbableElements.length - 1]) != null ? _b2 : null;
  return { start, end };
}
function getSlottedChildrenOutsideRootElement(slotElement, root) {
  var _a6;
  return ((_a6 = slotElement.getRootNode({ composed: true })) == null ? void 0 : _a6.host) !== root;
}
function getTabbableElements(root) {
  const walkedEls = /* @__PURE__ */ new WeakMap();
  const tabbableElements = [];
  function walk(el) {
    if (el instanceof Element) {
      if (el.hasAttribute("inert") || el.closest("[inert]")) {
        return;
      }
      if (walkedEls.has(el)) {
        return;
      }
      walkedEls.set(el, true);
      if (!tabbableElements.includes(el) && isTabbable(el)) {
        tabbableElements.push(el);
      }
      if (el instanceof HTMLSlotElement && getSlottedChildrenOutsideRootElement(el, root)) {
        el.assignedElements({ flatten: true }).forEach((assignedEl) => {
          walk(assignedEl);
        });
      }
      if (el.shadowRoot !== null && el.shadowRoot.mode === "open") {
        walk(el.shadowRoot);
      }
    }
    for (const e11 of el.children) {
      walk(e11);
    }
  }
  walk(root);
  return tabbableElements.sort((a4, b3) => {
    const aTabindex = Number(a4.getAttribute("tabindex")) || 0;
    const bTabindex = Number(b3.getAttribute("tabindex")) || 0;
    return bTabindex - aTabindex;
  });
}

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3KSWVBQ5.js
var popup_styles_default = i`
  :host {
    --arrow-color: var(--sl-color-neutral-1000);
    --arrow-size: 6px;

    /*
     * These properties are computed to account for the arrow's dimensions after being rotated 45º. The constant
     * 0.7071 is derived from sin(45), which is the diagonal size of the arrow's container after rotating.
     */
    --arrow-size-diagonal: calc(var(--arrow-size) * 0.7071);
    --arrow-padding-offset: calc(var(--arrow-size-diagonal) - var(--arrow-size));

    display: contents;
  }

  .popup {
    position: absolute;
    isolation: isolate;
    max-width: var(--auto-size-available-width, none);
    max-height: var(--auto-size-available-height, none);
  }

  .popup--fixed {
    position: fixed;
  }

  .popup:not(.popup--active) {
    display: none;
  }

  .popup__arrow {
    position: absolute;
    width: calc(var(--arrow-size-diagonal) * 2);
    height: calc(var(--arrow-size-diagonal) * 2);
    rotate: 45deg;
    background: var(--arrow-color);
    z-index: -1;
  }

  /* Hover bridge */
  .popup-hover-bridge:not(.popup-hover-bridge--visible) {
    display: none;
  }

  .popup-hover-bridge {
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--hover-bridge-top-left-x, 0) var(--hover-bridge-top-left-y, 0),
      var(--hover-bridge-top-right-x, 0) var(--hover-bridge-top-right-y, 0),
      var(--hover-bridge-bottom-right-x, 0) var(--hover-bridge-bottom-right-y, 0),
      var(--hover-bridge-bottom-left-x, 0) var(--hover-bridge-bottom-left-y, 0)
    );
  }
`;

// node_modules/.pnpm/@floating-ui+utils@0.2.1/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v2) => ({
  x: v2,
  y: v2
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

// node_modules/.pnpm/@floating-ui+core@1.6.0/node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y3
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i6 = 0; i6 < validMiddleware.length; i6++) {
    const {
      name,
      fn
    } = validMiddleware[i6];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y3,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y3 = nextY != null ? nextY : y3;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y3
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i6 = -1;
    }
  }
  return {
    x: x2,
    y: y3,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y3,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x: x2,
    y: y3
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y3,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y3
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d3) => d3.overflows[0] <= 0).sort((a4, b3) => a4.overflows[1] - b3.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d3) => [d3.placement, d3.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a4, b3) => a4[1] - b3[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y3,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y3 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y3,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y4
            } = _ref;
            return {
              x: x3,
              y: y4
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y3
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y3
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        const maximumClippingWidth = width - overflow.left - overflow.right;
        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/.pnpm/@floating-ui+utils@0.2.1/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css = getComputedStyle2(element);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

// node_modules/.pnpm/@floating-ui+dom@1.6.3/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round(rect.width) : rect.width) / width;
  let y3 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y3 || !Number.isFinite(y3)) {
    y3 = 1;
  }
  return {
    x: x2,
    y: y3
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y3 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = currentWin.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y3 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y3 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = currentWin.frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y3
  });
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(floating) {
  return topLayerSelectors.some((selector) => {
    try {
      return floating.matches(selector);
    } catch (e11) {
      return false;
    }
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y3 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y3
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y3 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y3
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y3 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y3
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x2 = rect.left + scroll.scrollLeft - offsets.x;
  const y3 = rect.top + scroll.scrollTop - offsets.y;
  return {
    x: x2,
    y: y3,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const window2 = getWindow(element);
  if (!isHTMLElement(element) || isTopLayer(element)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      ...await getDimensionsFn(data.floating)
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e11) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update2, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update2, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update2);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update2();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update2();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update2();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2);
      ancestorResize && ancestor.removeEventListener("resize", update2);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var arrow2 = arrow;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/.pnpm/composed-offset-position@0.0.4/node_modules/composed-offset-position/dist/composed-offset-position.browser.min.mjs
function t6(t7) {
  return r7(t7);
}
function o7(t7) {
  return t7.assignedSlot ? t7.assignedSlot : t7.parentNode instanceof ShadowRoot ? t7.parentNode.host : t7.parentNode;
}
function r7(t7) {
  for (let e11 = t7; e11; e11 = o7(e11))
    if (e11 instanceof Element && "none" === getComputedStyle(e11).display)
      return null;
  for (let e11 = o7(t7); e11; e11 = o7(e11)) {
    if (!(e11 instanceof Element))
      continue;
    const t8 = getComputedStyle(e11);
    if ("contents" !== t8.display) {
      if ("static" !== t8.position || "none" !== t8.filter)
        return e11;
      if ("BODY" === e11.tagName)
        return e11;
    }
  }
  return null;
}

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.SUWKRDXP.js
function isVirtualElement(e11) {
  return e11 !== null && typeof e11 === "object" && "getBoundingClientRect" in e11 && ("contextElement" in e11 ? e11 instanceof Element : true);
}
var SlPopup = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.active = false;
    this.placement = "top";
    this.strategy = "absolute";
    this.distance = 0;
    this.skidding = 0;
    this.arrow = false;
    this.arrowPlacement = "anchor";
    this.arrowPadding = 10;
    this.flip = false;
    this.flipFallbackPlacements = "";
    this.flipFallbackStrategy = "best-fit";
    this.flipPadding = 0;
    this.shift = false;
    this.shiftPadding = 0;
    this.autoSizePadding = 0;
    this.hoverBridge = false;
    this.updateHoverBridge = () => {
      if (this.hoverBridge && this.anchorEl) {
        const anchorRect = this.anchorEl.getBoundingClientRect();
        const popupRect = this.popup.getBoundingClientRect();
        const isVertical = this.placement.includes("top") || this.placement.includes("bottom");
        let topLeftX = 0;
        let topLeftY = 0;
        let topRightX = 0;
        let topRightY = 0;
        let bottomLeftX = 0;
        let bottomLeftY = 0;
        let bottomRightX = 0;
        let bottomRightY = 0;
        if (isVertical) {
          if (anchorRect.top < popupRect.top) {
            topLeftX = anchorRect.left;
            topLeftY = anchorRect.bottom;
            topRightX = anchorRect.right;
            topRightY = anchorRect.bottom;
            bottomLeftX = popupRect.left;
            bottomLeftY = popupRect.top;
            bottomRightX = popupRect.right;
            bottomRightY = popupRect.top;
          } else {
            topLeftX = popupRect.left;
            topLeftY = popupRect.bottom;
            topRightX = popupRect.right;
            topRightY = popupRect.bottom;
            bottomLeftX = anchorRect.left;
            bottomLeftY = anchorRect.top;
            bottomRightX = anchorRect.right;
            bottomRightY = anchorRect.top;
          }
        } else {
          if (anchorRect.left < popupRect.left) {
            topLeftX = anchorRect.right;
            topLeftY = anchorRect.top;
            topRightX = popupRect.left;
            topRightY = popupRect.top;
            bottomLeftX = anchorRect.right;
            bottomLeftY = anchorRect.bottom;
            bottomRightX = popupRect.left;
            bottomRightY = popupRect.bottom;
          } else {
            topLeftX = popupRect.right;
            topLeftY = popupRect.top;
            topRightX = anchorRect.left;
            topRightY = anchorRect.top;
            bottomLeftX = popupRect.right;
            bottomLeftY = popupRect.bottom;
            bottomRightX = anchorRect.left;
            bottomRightY = anchorRect.bottom;
          }
        }
        this.style.setProperty("--hover-bridge-top-left-x", `${topLeftX}px`);
        this.style.setProperty("--hover-bridge-top-left-y", `${topLeftY}px`);
        this.style.setProperty("--hover-bridge-top-right-x", `${topRightX}px`);
        this.style.setProperty("--hover-bridge-top-right-y", `${topRightY}px`);
        this.style.setProperty("--hover-bridge-bottom-left-x", `${bottomLeftX}px`);
        this.style.setProperty("--hover-bridge-bottom-left-y", `${bottomLeftY}px`);
        this.style.setProperty("--hover-bridge-bottom-right-x", `${bottomRightX}px`);
        this.style.setProperty("--hover-bridge-bottom-right-y", `${bottomRightY}px`);
      }
    };
  }
  async connectedCallback() {
    super.connectedCallback();
    await this.updateComplete;
    this.start();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.stop();
  }
  async updated(changedProps) {
    super.updated(changedProps);
    if (changedProps.has("active")) {
      if (this.active) {
        this.start();
      } else {
        this.stop();
      }
    }
    if (changedProps.has("anchor")) {
      this.handleAnchorChange();
    }
    if (this.active) {
      await this.updateComplete;
      this.reposition();
    }
  }
  async handleAnchorChange() {
    await this.stop();
    if (this.anchor && typeof this.anchor === "string") {
      const root = this.getRootNode();
      this.anchorEl = root.getElementById(this.anchor);
    } else if (this.anchor instanceof Element || isVirtualElement(this.anchor)) {
      this.anchorEl = this.anchor;
    } else {
      this.anchorEl = this.querySelector('[slot="anchor"]');
    }
    if (this.anchorEl instanceof HTMLSlotElement) {
      this.anchorEl = this.anchorEl.assignedElements({ flatten: true })[0];
    }
    if (this.anchorEl) {
      this.start();
    }
  }
  start() {
    if (!this.anchorEl) {
      return;
    }
    this.cleanup = autoUpdate(this.anchorEl, this.popup, () => {
      this.reposition();
    });
  }
  async stop() {
    return new Promise((resolve) => {
      if (this.cleanup) {
        this.cleanup();
        this.cleanup = void 0;
        this.removeAttribute("data-current-placement");
        this.style.removeProperty("--auto-size-available-width");
        this.style.removeProperty("--auto-size-available-height");
        requestAnimationFrame(() => resolve());
      } else {
        resolve();
      }
    });
  }
  /** Forces the popup to recalculate and reposition itself. */
  reposition() {
    if (!this.active || !this.anchorEl) {
      return;
    }
    const middleware = [
      // The offset middleware goes first
      offset({ mainAxis: this.distance, crossAxis: this.skidding })
    ];
    if (this.sync) {
      middleware.push(
        size2({
          apply: ({ rects }) => {
            const syncWidth = this.sync === "width" || this.sync === "both";
            const syncHeight = this.sync === "height" || this.sync === "both";
            this.popup.style.width = syncWidth ? `${rects.reference.width}px` : "";
            this.popup.style.height = syncHeight ? `${rects.reference.height}px` : "";
          }
        })
      );
    } else {
      this.popup.style.width = "";
      this.popup.style.height = "";
    }
    if (this.flip) {
      middleware.push(
        flip2({
          boundary: this.flipBoundary,
          // @ts-expect-error - We're converting a string attribute to an array here
          fallbackPlacements: this.flipFallbackPlacements,
          fallbackStrategy: this.flipFallbackStrategy === "best-fit" ? "bestFit" : "initialPlacement",
          padding: this.flipPadding
        })
      );
    }
    if (this.shift) {
      middleware.push(
        shift2({
          boundary: this.shiftBoundary,
          padding: this.shiftPadding
        })
      );
    }
    if (this.autoSize) {
      middleware.push(
        size2({
          boundary: this.autoSizeBoundary,
          padding: this.autoSizePadding,
          apply: ({ availableWidth, availableHeight }) => {
            if (this.autoSize === "vertical" || this.autoSize === "both") {
              this.style.setProperty("--auto-size-available-height", `${availableHeight}px`);
            } else {
              this.style.removeProperty("--auto-size-available-height");
            }
            if (this.autoSize === "horizontal" || this.autoSize === "both") {
              this.style.setProperty("--auto-size-available-width", `${availableWidth}px`);
            } else {
              this.style.removeProperty("--auto-size-available-width");
            }
          }
        })
      );
    } else {
      this.style.removeProperty("--auto-size-available-width");
      this.style.removeProperty("--auto-size-available-height");
    }
    if (this.arrow) {
      middleware.push(
        arrow2({
          element: this.arrowEl,
          padding: this.arrowPadding
        })
      );
    }
    const getOffsetParent2 = this.strategy === "absolute" ? (element) => platform.getOffsetParent(element, t6) : platform.getOffsetParent;
    computePosition2(this.anchorEl, this.popup, {
      placement: this.placement,
      middleware,
      strategy: this.strategy,
      platform: __spreadProps(__spreadValues({}, platform), {
        getOffsetParent: getOffsetParent2
      })
    }).then(({ x: x2, y: y3, middlewareData, placement }) => {
      const isRtl = getComputedStyle(this).direction === "rtl";
      const staticSide = { top: "bottom", right: "left", bottom: "top", left: "right" }[placement.split("-")[0]];
      this.setAttribute("data-current-placement", placement);
      Object.assign(this.popup.style, {
        left: `${x2}px`,
        top: `${y3}px`
      });
      if (this.arrow) {
        const arrowX = middlewareData.arrow.x;
        const arrowY = middlewareData.arrow.y;
        let top = "";
        let right = "";
        let bottom = "";
        let left = "";
        if (this.arrowPlacement === "start") {
          const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          top = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          right = isRtl ? value : "";
          left = isRtl ? "" : value;
        } else if (this.arrowPlacement === "end") {
          const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          right = isRtl ? "" : value;
          left = isRtl ? value : "";
          bottom = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
        } else if (this.arrowPlacement === "center") {
          left = typeof arrowX === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
          top = typeof arrowY === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
        } else {
          left = typeof arrowX === "number" ? `${arrowX}px` : "";
          top = typeof arrowY === "number" ? `${arrowY}px` : "";
        }
        Object.assign(this.arrowEl.style, {
          top,
          right,
          bottom,
          left,
          [staticSide]: "calc(var(--arrow-size-diagonal) * -1)"
        });
      }
    });
    requestAnimationFrame(() => this.updateHoverBridge());
    this.emit("sl-reposition");
  }
  render() {
    return x`
      <slot name="anchor" @slotchange=${this.handleAnchorChange}></slot>

      <span
        part="hover-bridge"
        class=${e8({
      "popup-hover-bridge": true,
      "popup-hover-bridge--visible": this.hoverBridge && this.active
    })}
      ></span>

      <div
        part="popup"
        class=${e8({
      popup: true,
      "popup--active": this.active,
      "popup--fixed": this.strategy === "fixed",
      "popup--has-arrow": this.arrow
    })}
      >
        <slot></slot>
        ${this.arrow ? x`<div part="arrow" class="popup__arrow" role="presentation"></div>` : ""}
      </div>
    `;
  }
};
SlPopup.styles = [component_styles_default, popup_styles_default];
__decorateClass([
  e5(".popup")
], SlPopup.prototype, "popup", 2);
__decorateClass([
  e5(".popup__arrow")
], SlPopup.prototype, "arrowEl", 2);
__decorateClass([
  n4()
], SlPopup.prototype, "anchor", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlPopup.prototype, "active", 2);
__decorateClass([
  n4({ reflect: true })
], SlPopup.prototype, "placement", 2);
__decorateClass([
  n4({ reflect: true })
], SlPopup.prototype, "strategy", 2);
__decorateClass([
  n4({ type: Number })
], SlPopup.prototype, "distance", 2);
__decorateClass([
  n4({ type: Number })
], SlPopup.prototype, "skidding", 2);
__decorateClass([
  n4({ type: Boolean })
], SlPopup.prototype, "arrow", 2);
__decorateClass([
  n4({ attribute: "arrow-placement" })
], SlPopup.prototype, "arrowPlacement", 2);
__decorateClass([
  n4({ attribute: "arrow-padding", type: Number })
], SlPopup.prototype, "arrowPadding", 2);
__decorateClass([
  n4({ type: Boolean })
], SlPopup.prototype, "flip", 2);
__decorateClass([
  n4({
    attribute: "flip-fallback-placements",
    converter: {
      fromAttribute: (value) => {
        return value.split(" ").map((p3) => p3.trim()).filter((p3) => p3 !== "");
      },
      toAttribute: (value) => {
        return value.join(" ");
      }
    }
  })
], SlPopup.prototype, "flipFallbackPlacements", 2);
__decorateClass([
  n4({ attribute: "flip-fallback-strategy" })
], SlPopup.prototype, "flipFallbackStrategy", 2);
__decorateClass([
  n4({ type: Object })
], SlPopup.prototype, "flipBoundary", 2);
__decorateClass([
  n4({ attribute: "flip-padding", type: Number })
], SlPopup.prototype, "flipPadding", 2);
__decorateClass([
  n4({ type: Boolean })
], SlPopup.prototype, "shift", 2);
__decorateClass([
  n4({ type: Object })
], SlPopup.prototype, "shiftBoundary", 2);
__decorateClass([
  n4({ attribute: "shift-padding", type: Number })
], SlPopup.prototype, "shiftPadding", 2);
__decorateClass([
  n4({ attribute: "auto-size" })
], SlPopup.prototype, "autoSize", 2);
__decorateClass([
  n4()
], SlPopup.prototype, "sync", 2);
__decorateClass([
  n4({ type: Object })
], SlPopup.prototype, "autoSizeBoundary", 2);
__decorateClass([
  n4({ attribute: "auto-size-padding", type: Number })
], SlPopup.prototype, "autoSizePadding", 2);
__decorateClass([
  n4({ attribute: "hover-bridge", type: Boolean })
], SlPopup.prototype, "hoverBridge", 2);

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.DHU6MIVB.js
var defaultAnimationRegistry = /* @__PURE__ */ new Map();
var customAnimationRegistry = /* @__PURE__ */ new WeakMap();
function ensureAnimation(animation) {
  return animation != null ? animation : { keyframes: [], options: { duration: 0 } };
}
function getLogicalAnimation(animation, dir) {
  if (dir.toLowerCase() === "rtl") {
    return {
      keyframes: animation.rtlKeyframes || animation.keyframes,
      options: animation.options
    };
  }
  return animation;
}
function setDefaultAnimation(animationName, animation) {
  defaultAnimationRegistry.set(animationName, ensureAnimation(animation));
}
function getAnimation(el, animationName, options) {
  const customAnimation = customAnimationRegistry.get(el);
  if (customAnimation == null ? void 0 : customAnimation[animationName]) {
    return getLogicalAnimation(customAnimation[animationName], options.dir);
  }
  const defaultAnimation = defaultAnimationRegistry.get(animationName);
  if (defaultAnimation) {
    return getLogicalAnimation(defaultAnimation, options.dir);
  }
  return {
    keyframes: [],
    options: { duration: 0 }
  };
}

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.B4BZKR24.js
function waitForEvent(el, eventName) {
  return new Promise((resolve) => {
    function done(event) {
      if (event.target === el) {
        el.removeEventListener(eventName, done);
        resolve();
      }
    }
    el.addEventListener(eventName, done);
  });
}

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LHI6QEL2.js
function animateTo(el, keyframes, options) {
  return new Promise((resolve) => {
    if ((options == null ? void 0 : options.duration) === Infinity) {
      throw new Error("Promise-based animations must be finite.");
    }
    const animation = el.animate(keyframes, __spreadProps(__spreadValues({}, options), {
      duration: prefersReducedMotion() ? 0 : options.duration
    }));
    animation.addEventListener("cancel", resolve, { once: true });
    animation.addEventListener("finish", resolve, { once: true });
  });
}
function prefersReducedMotion() {
  const query = window.matchMedia("(prefers-reduced-motion: reduce)");
  return query.matches;
}
function stopAnimations(el) {
  return Promise.all(
    el.getAnimations().map((animation) => {
      return new Promise((resolve) => {
        animation.cancel();
        requestAnimationFrame(resolve);
      });
    })
  );
}

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.FLYTFYGC.js
var SlDropdown = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.open = false;
    this.placement = "bottom-start";
    this.disabled = false;
    this.stayOpenOnSelect = false;
    this.distance = 0;
    this.skidding = 0;
    this.hoist = false;
    this.sync = void 0;
    this.handleKeyDown = (event) => {
      if (this.open && event.key === "Escape") {
        event.stopPropagation();
        this.hide();
        this.focusOnTrigger();
      }
    };
    this.handleDocumentKeyDown = (event) => {
      var _a6;
      if (event.key === "Escape" && this.open && !this.closeWatcher) {
        event.stopPropagation();
        this.focusOnTrigger();
        this.hide();
        return;
      }
      if (event.key === "Tab") {
        if (this.open && ((_a6 = document.activeElement) == null ? void 0 : _a6.tagName.toLowerCase()) === "sl-menu-item") {
          event.preventDefault();
          this.hide();
          this.focusOnTrigger();
          return;
        }
        setTimeout(() => {
          var _a22, _b2, _c;
          const activeElement = ((_a22 = this.containingElement) == null ? void 0 : _a22.getRootNode()) instanceof ShadowRoot ? (_c = (_b2 = document.activeElement) == null ? void 0 : _b2.shadowRoot) == null ? void 0 : _c.activeElement : document.activeElement;
          if (!this.containingElement || (activeElement == null ? void 0 : activeElement.closest(this.containingElement.tagName.toLowerCase())) !== this.containingElement) {
            this.hide();
          }
        });
      }
    };
    this.handleDocumentMouseDown = (event) => {
      const path = event.composedPath();
      if (this.containingElement && !path.includes(this.containingElement)) {
        this.hide();
      }
    };
    this.handlePanelSelect = (event) => {
      const target = event.target;
      if (!this.stayOpenOnSelect && target.tagName.toLowerCase() === "sl-menu") {
        this.hide();
        this.focusOnTrigger();
      }
    };
  }
  connectedCallback() {
    super.connectedCallback();
    if (!this.containingElement) {
      this.containingElement = this;
    }
  }
  firstUpdated() {
    this.panel.hidden = !this.open;
    if (this.open) {
      this.addOpenListeners();
      this.popup.active = true;
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeOpenListeners();
    this.hide();
  }
  focusOnTrigger() {
    const trigger = this.trigger.assignedElements({ flatten: true })[0];
    if (typeof (trigger == null ? void 0 : trigger.focus) === "function") {
      trigger.focus();
    }
  }
  getMenu() {
    return this.panel.assignedElements({ flatten: true }).find((el) => el.tagName.toLowerCase() === "sl-menu");
  }
  handleTriggerClick() {
    if (this.open) {
      this.hide();
    } else {
      this.show();
      this.focusOnTrigger();
    }
  }
  async handleTriggerKeyDown(event) {
    if ([" ", "Enter"].includes(event.key)) {
      event.preventDefault();
      this.handleTriggerClick();
      return;
    }
    const menu = this.getMenu();
    if (menu) {
      const menuItems = menu.getAllItems();
      const firstMenuItem = menuItems[0];
      const lastMenuItem = menuItems[menuItems.length - 1];
      if (["ArrowDown", "ArrowUp", "Home", "End"].includes(event.key)) {
        event.preventDefault();
        if (!this.open) {
          this.show();
          await this.updateComplete;
        }
        if (menuItems.length > 0) {
          this.updateComplete.then(() => {
            if (event.key === "ArrowDown" || event.key === "Home") {
              menu.setCurrentItem(firstMenuItem);
              firstMenuItem.focus();
            }
            if (event.key === "ArrowUp" || event.key === "End") {
              menu.setCurrentItem(lastMenuItem);
              lastMenuItem.focus();
            }
          });
        }
      }
    }
  }
  handleTriggerKeyUp(event) {
    if (event.key === " ") {
      event.preventDefault();
    }
  }
  handleTriggerSlotChange() {
    this.updateAccessibleTrigger();
  }
  //
  // Slotted triggers can be arbitrary content, but we need to link them to the dropdown panel with `aria-haspopup` and
  // `aria-expanded`. These must be applied to the "accessible trigger" (the tabbable portion of the trigger element
  // that gets slotted in) so screen readers will understand them. The accessible trigger could be the slotted element,
  // a child of the slotted element, or an element in the slotted element's shadow root.
  //
  // For example, the accessible trigger of an <sl-button> is a <button> located inside its shadow root.
  //
  // To determine this, we assume the first tabbable element in the trigger slot is the "accessible trigger."
  //
  updateAccessibleTrigger() {
    const assignedElements = this.trigger.assignedElements({ flatten: true });
    const accessibleTrigger = assignedElements.find((el) => getTabbableBoundary(el).start);
    let target;
    if (accessibleTrigger) {
      switch (accessibleTrigger.tagName.toLowerCase()) {
        case "sl-button":
        case "sl-icon-button":
          target = accessibleTrigger.button;
          break;
        default:
          target = accessibleTrigger;
      }
      target.setAttribute("aria-haspopup", "true");
      target.setAttribute("aria-expanded", this.open ? "true" : "false");
    }
  }
  /** Shows the dropdown panel. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the dropdown panel */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  /**
   * Instructs the dropdown menu to reposition. Useful when the position or size of the trigger changes when the menu
   * is activated.
   */
  reposition() {
    this.popup.reposition();
  }
  addOpenListeners() {
    var _a6;
    this.panel.addEventListener("sl-select", this.handlePanelSelect);
    if ("CloseWatcher" in window) {
      (_a6 = this.closeWatcher) == null ? void 0 : _a6.destroy();
      this.closeWatcher = new CloseWatcher();
      this.closeWatcher.onclose = () => {
        this.hide();
        this.focusOnTrigger();
      };
    } else {
      this.panel.addEventListener("keydown", this.handleKeyDown);
    }
    document.addEventListener("keydown", this.handleDocumentKeyDown);
    document.addEventListener("mousedown", this.handleDocumentMouseDown);
  }
  removeOpenListeners() {
    var _a6;
    if (this.panel) {
      this.panel.removeEventListener("sl-select", this.handlePanelSelect);
      this.panel.removeEventListener("keydown", this.handleKeyDown);
    }
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
    document.removeEventListener("mousedown", this.handleDocumentMouseDown);
    (_a6 = this.closeWatcher) == null ? void 0 : _a6.destroy();
  }
  async handleOpenChange() {
    if (this.disabled) {
      this.open = false;
      return;
    }
    this.updateAccessibleTrigger();
    if (this.open) {
      this.emit("sl-show");
      this.addOpenListeners();
      await stopAnimations(this);
      this.panel.hidden = false;
      this.popup.active = true;
      const { keyframes, options } = getAnimation(this, "dropdown.show", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, keyframes, options);
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      this.removeOpenListeners();
      await stopAnimations(this);
      const { keyframes, options } = getAnimation(this, "dropdown.hide", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, keyframes, options);
      this.panel.hidden = true;
      this.popup.active = false;
      this.emit("sl-after-hide");
    }
  }
  render() {
    return x`
      <sl-popup
        part="base"
        id="dropdown"
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        auto-size="vertical"
        auto-size-padding="10"
        sync=${o6(this.sync ? this.sync : void 0)}
        class=${e8({
      dropdown: true,
      "dropdown--open": this.open
    })}
      >
        <slot
          name="trigger"
          slot="anchor"
          part="trigger"
          class="dropdown__trigger"
          @click=${this.handleTriggerClick}
          @keydown=${this.handleTriggerKeyDown}
          @keyup=${this.handleTriggerKeyUp}
          @slotchange=${this.handleTriggerSlotChange}
        ></slot>

        <div aria-hidden=${this.open ? "false" : "true"} aria-labelledby="dropdown">
          <slot part="panel" class="dropdown__panel"></slot>
        </div>
      </sl-popup>
    `;
  }
};
SlDropdown.styles = [component_styles_default, dropdown_styles_default];
SlDropdown.dependencies = { "sl-popup": SlPopup };
__decorateClass([
  e5(".dropdown")
], SlDropdown.prototype, "popup", 2);
__decorateClass([
  e5(".dropdown__trigger")
], SlDropdown.prototype, "trigger", 2);
__decorateClass([
  e5(".dropdown__panel")
], SlDropdown.prototype, "panel", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlDropdown.prototype, "open", 2);
__decorateClass([
  n4({ reflect: true })
], SlDropdown.prototype, "placement", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlDropdown.prototype, "disabled", 2);
__decorateClass([
  n4({ attribute: "stay-open-on-select", type: Boolean, reflect: true })
], SlDropdown.prototype, "stayOpenOnSelect", 2);
__decorateClass([
  n4({ attribute: false })
], SlDropdown.prototype, "containingElement", 2);
__decorateClass([
  n4({ type: Number })
], SlDropdown.prototype, "distance", 2);
__decorateClass([
  n4({ type: Number })
], SlDropdown.prototype, "skidding", 2);
__decorateClass([
  n4({ type: Boolean })
], SlDropdown.prototype, "hoist", 2);
__decorateClass([
  n4({ reflect: true })
], SlDropdown.prototype, "sync", 2);
__decorateClass([
  watch("open", { waitUntilFirstUpdate: true })
], SlDropdown.prototype, "handleOpenChange", 1);
setDefaultAnimation("dropdown.show", {
  keyframes: [
    { opacity: 0, scale: 0.9 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 100, easing: "ease" }
});
setDefaultAnimation("dropdown.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.9 }
  ],
  options: { duration: 100, easing: "ease" }
});

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.OJFFDYG4.js
SlDropdown.define("sl-dropdown");

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.22M42QYS.js
SlIcon.define("sl-icon");

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.GGT72J62.js
var input_styles_default = i`
  :host {
    display: block;
  }

  .input {
    flex: 1 1 auto;
    display: inline-flex;
    align-items: stretch;
    justify-content: start;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: text;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  /* Standard inputs */
  .input--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .input--standard:hover:not(.input--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }

  .input--standard.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  .input--standard.input--focused:not(.input--disabled) .input__control {
    color: var(--sl-input-color-focus);
  }

  .input--standard.input--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input--standard.input--disabled .input__control {
    color: var(--sl-input-color-disabled);
  }

  .input--standard.input--disabled .input__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled inputs */
  .input--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .input--filled:hover:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .input--filled.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .input--filled.input--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input__control {
    flex: 1 1 auto;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    min-width: 0;
    height: 100%;
    color: var(--sl-input-color);
    border: none;
    background: inherit;
    box-shadow: none;
    padding: 0;
    margin: 0;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .input__control::-webkit-search-decoration,
  .input__control::-webkit-search-cancel-button,
  .input__control::-webkit-search-results-button,
  .input__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .input__control:-webkit-autofill,
  .input__control:-webkit-autofill:hover,
  .input__control:-webkit-autofill:focus,
  .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-background-color-hover) inset !important;
    -webkit-text-fill-color: var(--sl-color-primary-500);
    caret-color: var(--sl-input-color);
  }

  .input--filled .input__control:-webkit-autofill,
  .input--filled .input__control:-webkit-autofill:hover,
  .input--filled .input__control:-webkit-autofill:focus,
  .input--filled .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-filled-background-color) inset !important;
  }

  .input__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
    -webkit-user-select: none;
  }

  .input:hover:not(.input--disabled) .input__control {
    color: var(--sl-input-color-hover);
  }

  .input__control:focus {
    outline: none;
  }

  .input__prefix,
  .input__suffix {
    display: inline-flex;
    flex: 0 0 auto;
    align-items: center;
    cursor: default;
  }

  .input__prefix ::slotted(sl-icon),
  .input__suffix ::slotted(sl-icon) {
    color: var(--sl-input-icon-color);
  }

  /*
   * Size modifiers
   */

  .input--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    height: var(--sl-input-height-small);
  }

  .input--small .input__control {
    height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-small);
  }

  .input--small .input__clear,
  .input--small .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-small) * 2);
  }

  .input--small .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .input--small .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .input--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    height: var(--sl-input-height-medium);
  }

  .input--medium .input__control {
    height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-medium);
  }

  .input--medium .input__clear,
  .input--medium .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-medium) * 2);
  }

  .input--medium .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .input--medium .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .input--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    height: var(--sl-input-height-large);
  }

  .input--large .input__control {
    height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-large);
  }

  .input--large .input__clear,
  .input--large .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-large) * 2);
  }

  .input--large .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .input--large .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  /*
   * Pill modifier
   */

  .input--pill.input--small {
    border-radius: var(--sl-input-height-small);
  }

  .input--pill.input--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .input--pill.input--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Clearable + Password Toggle
   */

  .input__clear,
  .input__password-toggle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .input__clear:hover,
  .input__password-toggle:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .input__clear:focus,
  .input__password-toggle:focus {
    outline: none;
  }

  /* Don't show the browser's password toggle in Edge */
  ::-ms-reveal {
    display: none;
  }

  /* Hide the built-in number spinner */
  .input--no-spin-buttons input[type='number']::-webkit-outer-spin-button,
  .input--no-spin-buttons input[type='number']::-webkit-inner-spin-button {
    -webkit-appearance: none;
    display: none;
  }

  .input--no-spin-buttons input[type='number'] {
    -moz-appearance: textfield;
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.GI7VDIWX.js
var defaultValue = (propertyName = "value") => (proto, key) => {
  const ctor = proto.constructor;
  const attributeChangedCallback = ctor.prototype.attributeChangedCallback;
  ctor.prototype.attributeChangedCallback = function(name, old, value) {
    var _a6;
    const options = ctor.getPropertyOptions(propertyName);
    const attributeName = typeof options.attribute === "string" ? options.attribute : propertyName;
    if (name === attributeName) {
      const converter = options.converter || u;
      const fromAttribute = typeof converter === "function" ? converter : (_a6 = converter == null ? void 0 : converter.fromAttribute) != null ? _a6 : u.fromAttribute;
      const newValue = fromAttribute(value, options.type);
      if (this[propertyName] !== newValue) {
        this[key] = newValue;
      }
    }
    attributeChangedCallback.call(this, name, old, value);
  };
};

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.SI4ACBFK.js
var form_control_styles_default = i`
  .form-control .form-control__label {
    display: none;
  }

  .form-control .form-control__help-text {
    display: none;
  }

  /* Label */
  .form-control--has-label .form-control__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    margin-bottom: var(--sl-spacing-3x-small);
  }

  .form-control--has-label.form-control--small .form-control__label {
    font-size: var(--sl-input-label-font-size-small);
  }

  .form-control--has-label.form-control--medium .form-control__label {
    font-size: var(--sl-input-label-font-size-medium);
  }

  .form-control--has-label.form-control--large .form-control__label {
    font-size: var(--sl-input-label-font-size-large);
  }

  :host([required]) .form-control--has-label .form-control__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
    color: var(--sl-input-required-content-color);
  }

  /* Help text */
  .form-control--has-help-text .form-control__help-text {
    display: block;
    color: var(--sl-input-help-text-color);
    margin-top: var(--sl-spacing-3x-small);
  }

  .form-control--has-help-text.form-control--small .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-small);
  }

  .form-control--has-help-text.form-control--medium .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-medium);
  }

  .form-control--has-help-text.form-control--large .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-large);
  }

  .form-control--has-help-text.form-control--radio-group .form-control__help-text {
    margin-top: var(--sl-spacing-2x-small);
  }
`;

// node_modules/.pnpm/lit-html@3.1.2/node_modules/lit-html/directives/live.js
var l4 = e7(class extends i4 {
  constructor(r8) {
    if (super(r8), r8.type !== t5.PROPERTY && r8.type !== t5.ATTRIBUTE && r8.type !== t5.BOOLEAN_ATTRIBUTE)
      throw Error("The `live` directive is not allowed on child or event bindings");
    if (!f3(r8))
      throw Error("`live` bindings can only contain a single expression");
  }
  render(r8) {
    return r8;
  }
  update(i6, [t7]) {
    if (t7 === w || t7 === T)
      return t7;
    const o10 = i6.element, l5 = i6.name;
    if (i6.type === t5.PROPERTY) {
      if (t7 === o10[l5])
        return w;
    } else if (i6.type === t5.BOOLEAN_ATTRIBUTE) {
      if (!!t7 === o10.hasAttribute(l5))
        return w;
    } else if (i6.type === t5.ATTRIBUTE && o10.getAttribute(l5) === t7 + "")
      return w;
    return m2(i6), t7;
  }
});

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.PSMXIF2T.js
var SlInput = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    });
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController2(this);
    this.hasFocus = false;
    this.title = "";
    this.__numberInput = Object.assign(document.createElement("input"), { type: "number" });
    this.__dateInput = Object.assign(document.createElement("input"), { type: "date" });
    this.type = "text";
    this.name = "";
    this.value = "";
    this.defaultValue = "";
    this.size = "medium";
    this.filled = false;
    this.pill = false;
    this.label = "";
    this.helpText = "";
    this.clearable = false;
    this.disabled = false;
    this.placeholder = "";
    this.readonly = false;
    this.passwordToggle = false;
    this.passwordVisible = false;
    this.noSpinButtons = false;
    this.form = "";
    this.required = false;
    this.spellcheck = true;
  }
  //
  // NOTE: We use an in-memory input for these getters/setters instead of the one in the template because the properties
  // can be set before the component is rendered.
  //
  /**
   * Gets or sets the current value as a `Date` object. Returns `null` if the value can't be converted. This will use the native `<input type="{{type}}">` implementation and may result in an error.
   */
  get valueAsDate() {
    var _a6;
    this.__dateInput.type = this.type;
    this.__dateInput.value = this.value;
    return ((_a6 = this.input) == null ? void 0 : _a6.valueAsDate) || this.__dateInput.valueAsDate;
  }
  set valueAsDate(newValue) {
    this.__dateInput.type = this.type;
    this.__dateInput.valueAsDate = newValue;
    this.value = this.__dateInput.value;
  }
  /** Gets or sets the current value as a number. Returns `NaN` if the value can't be converted. */
  get valueAsNumber() {
    var _a6;
    this.__numberInput.value = this.value;
    return ((_a6 = this.input) == null ? void 0 : _a6.valueAsNumber) || this.__numberInput.valueAsNumber;
  }
  set valueAsNumber(newValue) {
    this.__numberInput.valueAsNumber = newValue;
    this.value = this.__numberInput.value;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleChange() {
    this.value = this.input.value;
    this.emit("sl-change");
  }
  handleClearClick(event) {
    event.preventDefault();
    if (this.value !== "") {
      this.value = "";
      this.emit("sl-clear");
      this.emit("sl-input");
      this.emit("sl-change");
    }
    this.input.focus();
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleInput() {
    this.value = this.input.value;
    this.formControlController.updateValidity();
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleKeyDown(event) {
    const hasModifier = event.metaKey || event.ctrlKey || event.shiftKey || event.altKey;
    if (event.key === "Enter" && !hasModifier) {
      setTimeout(() => {
        if (!event.defaultPrevented && !event.isComposing) {
          this.formControlController.submit();
        }
      });
    }
  }
  handlePasswordToggle() {
    this.passwordVisible = !this.passwordVisible;
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStepChange() {
    this.input.step = String(this.step);
    this.formControlController.updateValidity();
  }
  async handleValueChange() {
    await this.updateComplete;
    this.formControlController.updateValidity();
  }
  /** Sets focus on the input. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the input. */
  blur() {
    this.input.blur();
  }
  /** Selects all the text in the input. */
  select() {
    this.input.select();
  }
  /** Sets the start and end positions of the text selection (0-based). */
  setSelectionRange(selectionStart, selectionEnd, selectionDirection = "none") {
    this.input.setSelectionRange(selectionStart, selectionEnd, selectionDirection);
  }
  /** Replaces a range of text with a new string. */
  setRangeText(replacement, start, end, selectMode = "preserve") {
    const selectionStart = start != null ? start : this.input.selectionStart;
    const selectionEnd = end != null ? end : this.input.selectionEnd;
    this.input.setRangeText(replacement, selectionStart, selectionEnd, selectMode);
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Displays the browser picker for an input element (only works if the browser supports it for the input type). */
  showPicker() {
    if ("showPicker" in HTMLInputElement.prototype) {
      this.input.showPicker();
    }
  }
  /** Increments the value of a numeric input type by the value of the step attribute. */
  stepUp() {
    this.input.stepUp();
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Decrements the value of a numeric input type by the value of the step attribute. */
  stepDown() {
    this.input.stepDown();
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    const hasClearIcon = this.clearable && !this.disabled && !this.readonly;
    const isClearIconVisible = hasClearIcon && (typeof this.value === "number" || this.value.length > 0);
    return x`
      <div
        part="form-control"
        class=${e8({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${e8({
      input: true,
      // Sizes
      "input--small": this.size === "small",
      "input--medium": this.size === "medium",
      "input--large": this.size === "large",
      // States
      "input--pill": this.pill,
      "input--standard": !this.filled,
      "input--filled": this.filled,
      "input--disabled": this.disabled,
      "input--focused": this.hasFocus,
      "input--empty": !this.value,
      "input--no-spin-buttons": this.noSpinButtons
    })}
          >
            <span part="prefix" class="input__prefix">
              <slot name="prefix"></slot>
            </span>

            <input
              part="input"
              id="input"
              class="input__control"
              type=${this.type === "password" && this.passwordVisible ? "text" : this.type}
              title=${this.title}
              name=${o6(this.name)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${o6(this.placeholder)}
              minlength=${o6(this.minlength)}
              maxlength=${o6(this.maxlength)}
              min=${o6(this.min)}
              max=${o6(this.max)}
              step=${o6(this.step)}
              .value=${l4(this.value)}
              autocapitalize=${o6(this.autocapitalize)}
              autocomplete=${o6(this.autocomplete)}
              autocorrect=${o6(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${this.spellcheck}
              pattern=${o6(this.pattern)}
              enterkeyhint=${o6(this.enterkeyhint)}
              inputmode=${o6(this.inputmode)}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @keydown=${this.handleKeyDown}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            />

            ${isClearIconVisible ? x`
                  <button
                    part="clear-button"
                    class="input__clear"
                    type="button"
                    aria-label=${this.localize.term("clearEntry")}
                    @click=${this.handleClearClick}
                    tabindex="-1"
                  >
                    <slot name="clear-icon">
                      <sl-icon name="x-circle-fill" library="system"></sl-icon>
                    </slot>
                  </button>
                ` : ""}
            ${this.passwordToggle && !this.disabled ? x`
                  <button
                    part="password-toggle-button"
                    class="input__password-toggle"
                    type="button"
                    aria-label=${this.localize.term(this.passwordVisible ? "hidePassword" : "showPassword")}
                    @click=${this.handlePasswordToggle}
                    tabindex="-1"
                  >
                    ${this.passwordVisible ? x`
                          <slot name="show-password-icon">
                            <sl-icon name="eye-slash" library="system"></sl-icon>
                          </slot>
                        ` : x`
                          <slot name="hide-password-icon">
                            <sl-icon name="eye" library="system"></sl-icon>
                          </slot>
                        `}
                  </button>
                ` : ""}

            <span part="suffix" class="input__suffix">
              <slot name="suffix"></slot>
            </span>
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlInput.styles = [component_styles_default, form_control_styles_default, input_styles_default];
SlInput.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e5(".input__control")
], SlInput.prototype, "input", 2);
__decorateClass([
  r6()
], SlInput.prototype, "hasFocus", 2);
__decorateClass([
  n4()
], SlInput.prototype, "title", 2);
__decorateClass([
  n4({ reflect: true })
], SlInput.prototype, "type", 2);
__decorateClass([
  n4()
], SlInput.prototype, "name", 2);
__decorateClass([
  n4()
], SlInput.prototype, "value", 2);
__decorateClass([
  defaultValue()
], SlInput.prototype, "defaultValue", 2);
__decorateClass([
  n4({ reflect: true })
], SlInput.prototype, "size", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlInput.prototype, "filled", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlInput.prototype, "pill", 2);
__decorateClass([
  n4()
], SlInput.prototype, "label", 2);
__decorateClass([
  n4({ attribute: "help-text" })
], SlInput.prototype, "helpText", 2);
__decorateClass([
  n4({ type: Boolean })
], SlInput.prototype, "clearable", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlInput.prototype, "disabled", 2);
__decorateClass([
  n4()
], SlInput.prototype, "placeholder", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlInput.prototype, "readonly", 2);
__decorateClass([
  n4({ attribute: "password-toggle", type: Boolean })
], SlInput.prototype, "passwordToggle", 2);
__decorateClass([
  n4({ attribute: "password-visible", type: Boolean })
], SlInput.prototype, "passwordVisible", 2);
__decorateClass([
  n4({ attribute: "no-spin-buttons", type: Boolean })
], SlInput.prototype, "noSpinButtons", 2);
__decorateClass([
  n4({ reflect: true })
], SlInput.prototype, "form", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlInput.prototype, "required", 2);
__decorateClass([
  n4()
], SlInput.prototype, "pattern", 2);
__decorateClass([
  n4({ type: Number })
], SlInput.prototype, "minlength", 2);
__decorateClass([
  n4({ type: Number })
], SlInput.prototype, "maxlength", 2);
__decorateClass([
  n4()
], SlInput.prototype, "min", 2);
__decorateClass([
  n4()
], SlInput.prototype, "max", 2);
__decorateClass([
  n4()
], SlInput.prototype, "step", 2);
__decorateClass([
  n4()
], SlInput.prototype, "autocapitalize", 2);
__decorateClass([
  n4()
], SlInput.prototype, "autocorrect", 2);
__decorateClass([
  n4()
], SlInput.prototype, "autocomplete", 2);
__decorateClass([
  n4({ type: Boolean })
], SlInput.prototype, "autofocus", 2);
__decorateClass([
  n4()
], SlInput.prototype, "enterkeyhint", 2);
__decorateClass([
  n4({
    type: Boolean,
    converter: {
      // Allow "true|false" attribute values but keep the property boolean
      fromAttribute: (value) => !value || value === "false" ? false : true,
      toAttribute: (value) => value ? "true" : "false"
    }
  })
], SlInput.prototype, "spellcheck", 2);
__decorateClass([
  n4()
], SlInput.prototype, "inputmode", 2);
__decorateClass([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleDisabledChange", 1);
__decorateClass([
  watch("step", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleStepChange", 1);
__decorateClass([
  watch("value", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleValueChange", 1);

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3MM6BATO.js
SlInput.define("sl-input");

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.X2WW2TWJ.js
var rating_styles_default = i`
  :host {
    --symbol-color: var(--sl-color-neutral-300);
    --symbol-color-active: var(--sl-color-amber-500);
    --symbol-size: 1.2rem;
    --symbol-spacing: var(--sl-spacing-3x-small);

    display: inline-flex;
  }

  .rating {
    position: relative;
    display: inline-flex;
    border-radius: var(--sl-border-radius-medium);
    vertical-align: middle;
  }

  .rating:focus {
    outline: none;
  }

  .rating:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .rating__symbols {
    display: inline-flex;
    position: relative;
    font-size: var(--symbol-size);
    line-height: 0;
    color: var(--symbol-color);
    white-space: nowrap;
    cursor: pointer;
  }

  .rating__symbols > * {
    padding: var(--symbol-spacing);
  }

  .rating__symbol--active,
  .rating__partial--filled {
    color: var(--symbol-color-active);
  }

  .rating__partial-symbol-container {
    position: relative;
  }

  .rating__partial--filled {
    position: absolute;
    top: var(--symbol-spacing);
    left: var(--symbol-spacing);
  }

  .rating__symbol {
    transition: var(--sl-transition-fast) scale;
    pointer-events: none;
  }

  .rating__symbol--hover {
    scale: 1.2;
  }

  .rating--disabled .rating__symbols,
  .rating--readonly .rating__symbols {
    cursor: default;
  }

  .rating--disabled .rating__symbol--hover,
  .rating--readonly .rating__symbol--hover {
    scale: none;
  }

  .rating--disabled {
    opacity: 0.5;
  }

  .rating--disabled .rating__symbols {
    cursor: not-allowed;
  }

  /* Forced colors mode */
  @media (forced-colors: active) {
    .rating__symbol--active {
      color: SelectedItem;
    }
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.HF7GESMZ.js
function clamp2(value, min2, max2) {
  const noNegativeZero = (n7) => Object.is(n7, -0) ? 0 : n7;
  if (value < min2) {
    return noNegativeZero(min2);
  }
  if (value > max2) {
    return noNegativeZero(max2);
  }
  return noNegativeZero(value);
}

// node_modules/.pnpm/lit-html@3.1.2/node_modules/lit-html/directives/style-map.js
var n6 = "important";
var i5 = " !" + n6;
var o8 = e7(class extends i4 {
  constructor(t7) {
    var _a6;
    if (super(t7), t7.type !== t5.ATTRIBUTE || "style" !== t7.name || ((_a6 = t7.strings) == null ? void 0 : _a6.length) > 2)
      throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(t7) {
    return Object.keys(t7).reduce((e11, r8) => {
      const s5 = t7[r8];
      return null == s5 ? e11 : e11 + `${r8 = r8.includes("-") ? r8 : r8.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${s5};`;
    }, "");
  }
  update(e11, [r8]) {
    const { style: s5 } = e11.element;
    if (void 0 === this.ft)
      return this.ft = new Set(Object.keys(r8)), this.render(r8);
    for (const t7 of this.ft)
      null == r8[t7] && (this.ft.delete(t7), t7.includes("-") ? s5.removeProperty(t7) : s5[t7] = null);
    for (const t7 in r8) {
      const e12 = r8[t7];
      if (null != e12) {
        this.ft.add(t7);
        const r9 = "string" == typeof e12 && e12.endsWith(i5);
        t7.includes("-") || r9 ? s5.setProperty(t7, r9 ? e12.slice(0, -11) : e12, r9 ? n6 : "") : s5[t7] = e12;
      }
    }
    return w;
  }
});

// node_modules/.pnpm/lit-html@3.1.2/node_modules/lit-html/directives/unsafe-html.js
var e10 = class extends i4 {
  constructor(i6) {
    if (super(i6), this.it = T, i6.type !== t5.CHILD)
      throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(r8) {
    if (r8 === T || null == r8)
      return this._t = void 0, this.it = r8;
    if (r8 === w)
      return r8;
    if ("string" != typeof r8)
      throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (r8 === this.it)
      return this._t;
    this.it = r8;
    const s5 = [r8];
    return s5.raw = s5, this._t = { _$litType$: this.constructor.resultType, strings: s5, values: [] };
  }
};
e10.directiveName = "unsafeHTML", e10.resultType = 1;
var o9 = e7(e10);

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.GPQTYS3D.js
var SlRating = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.hoverValue = 0;
    this.isHovering = false;
    this.label = "";
    this.value = 0;
    this.max = 5;
    this.precision = 1;
    this.readonly = false;
    this.disabled = false;
    this.getSymbol = () => '<sl-icon name="star-fill" library="system"></sl-icon>';
  }
  getValueFromMousePosition(event) {
    return this.getValueFromXCoordinate(event.clientX);
  }
  getValueFromTouchPosition(event) {
    return this.getValueFromXCoordinate(event.touches[0].clientX);
  }
  getValueFromXCoordinate(coordinate) {
    const isRtl = this.localize.dir() === "rtl";
    const { left, right, width } = this.rating.getBoundingClientRect();
    const value = isRtl ? this.roundToPrecision((right - coordinate) / width * this.max, this.precision) : this.roundToPrecision((coordinate - left) / width * this.max, this.precision);
    return clamp2(value, 0, this.max);
  }
  handleClick(event) {
    if (this.disabled) {
      return;
    }
    this.setValue(this.getValueFromMousePosition(event));
    this.emit("sl-change");
  }
  setValue(newValue) {
    if (this.disabled || this.readonly) {
      return;
    }
    this.value = newValue === this.value ? 0 : newValue;
    this.isHovering = false;
  }
  handleKeyDown(event) {
    const isLtr = this.localize.dir() === "ltr";
    const isRtl = this.localize.dir() === "rtl";
    const oldValue = this.value;
    if (this.disabled || this.readonly) {
      return;
    }
    if (event.key === "ArrowDown" || isLtr && event.key === "ArrowLeft" || isRtl && event.key === "ArrowRight") {
      const decrement = event.shiftKey ? 1 : this.precision;
      this.value = Math.max(0, this.value - decrement);
      event.preventDefault();
    }
    if (event.key === "ArrowUp" || isLtr && event.key === "ArrowRight" || isRtl && event.key === "ArrowLeft") {
      const increment = event.shiftKey ? 1 : this.precision;
      this.value = Math.min(this.max, this.value + increment);
      event.preventDefault();
    }
    if (event.key === "Home") {
      this.value = 0;
      event.preventDefault();
    }
    if (event.key === "End") {
      this.value = this.max;
      event.preventDefault();
    }
    if (this.value !== oldValue) {
      this.emit("sl-change");
    }
  }
  handleMouseEnter(event) {
    this.isHovering = true;
    this.hoverValue = this.getValueFromMousePosition(event);
  }
  handleMouseMove(event) {
    this.hoverValue = this.getValueFromMousePosition(event);
  }
  handleMouseLeave() {
    this.isHovering = false;
  }
  handleTouchStart(event) {
    this.isHovering = true;
    this.hoverValue = this.getValueFromTouchPosition(event);
    event.preventDefault();
  }
  handleTouchMove(event) {
    this.hoverValue = this.getValueFromTouchPosition(event);
  }
  handleTouchEnd(event) {
    this.isHovering = false;
    this.setValue(this.hoverValue);
    this.emit("sl-change");
    event.preventDefault();
  }
  roundToPrecision(numberToRound, precision = 0.5) {
    const multiplier = 1 / precision;
    return Math.ceil(numberToRound * multiplier) / multiplier;
  }
  handleHoverValueChange() {
    this.emit("sl-hover", {
      detail: {
        phase: "move",
        value: this.hoverValue
      }
    });
  }
  handleIsHoveringChange() {
    this.emit("sl-hover", {
      detail: {
        phase: this.isHovering ? "start" : "end",
        value: this.hoverValue
      }
    });
  }
  /** Sets focus on the rating. */
  focus(options) {
    this.rating.focus(options);
  }
  /** Removes focus from the rating. */
  blur() {
    this.rating.blur();
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    const counter = Array.from(Array(this.max).keys());
    let displayValue = 0;
    if (this.disabled || this.readonly) {
      displayValue = this.value;
    } else {
      displayValue = this.isHovering ? this.hoverValue : this.value;
    }
    return x`
      <div
        part="base"
        class=${e8({
      rating: true,
      "rating--readonly": this.readonly,
      "rating--disabled": this.disabled,
      "rating--rtl": isRtl
    })}
        role="slider"
        aria-label=${this.label}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-readonly=${this.readonly ? "true" : "false"}
        aria-valuenow=${this.value}
        aria-valuemin=${0}
        aria-valuemax=${this.max}
        tabindex=${this.disabled ? "-1" : "0"}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mouseenter=${this.handleMouseEnter}
        @touchstart=${this.handleTouchStart}
        @mouseleave=${this.handleMouseLeave}
        @touchend=${this.handleTouchEnd}
        @mousemove=${this.handleMouseMove}
        @touchmove=${this.handleTouchMove}
      >
        <span class="rating__symbols">
          ${counter.map((index) => {
      if (displayValue > index && displayValue < index + 1) {
        return x`
                <span
                  class=${e8({
          rating__symbol: true,
          "rating__partial-symbol-container": true,
          "rating__symbol--hover": this.isHovering && Math.ceil(displayValue) === index + 1
        })}
                  role="presentation"
                >
                  <div
                    style=${o8({
          clipPath: isRtl ? `inset(0 ${(displayValue - index) * 100}% 0 0)` : `inset(0 0 0 ${(displayValue - index) * 100}%)`
        })}
                  >
                    ${o9(this.getSymbol(index + 1))}
                  </div>
                  <div
                    class="rating__partial--filled"
                    style=${o8({
          clipPath: isRtl ? `inset(0 0 0 ${100 - (displayValue - index) * 100}%)` : `inset(0 ${100 - (displayValue - index) * 100}% 0 0)`
        })}
                  >
                    ${o9(this.getSymbol(index + 1))}
                  </div>
                </span>
              `;
      }
      return x`
              <span
                class=${e8({
        rating__symbol: true,
        "rating__symbol--hover": this.isHovering && Math.ceil(displayValue) === index + 1,
        "rating__symbol--active": displayValue >= index + 1
      })}
                role="presentation"
              >
                ${o9(this.getSymbol(index + 1))}
              </span>
            `;
    })}
        </span>
      </div>
    `;
  }
};
SlRating.styles = [component_styles_default, rating_styles_default];
SlRating.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e5(".rating")
], SlRating.prototype, "rating", 2);
__decorateClass([
  r6()
], SlRating.prototype, "hoverValue", 2);
__decorateClass([
  r6()
], SlRating.prototype, "isHovering", 2);
__decorateClass([
  n4()
], SlRating.prototype, "label", 2);
__decorateClass([
  n4({ type: Number })
], SlRating.prototype, "value", 2);
__decorateClass([
  n4({ type: Number })
], SlRating.prototype, "max", 2);
__decorateClass([
  n4({ type: Number })
], SlRating.prototype, "precision", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlRating.prototype, "readonly", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlRating.prototype, "disabled", 2);
__decorateClass([
  n4()
], SlRating.prototype, "getSymbol", 2);
__decorateClass([
  t3({ passive: true })
], SlRating.prototype, "handleTouchMove", 1);
__decorateClass([
  watch("hoverValue")
], SlRating.prototype, "handleHoverValueChange", 1);
__decorateClass([
  watch("isHovering")
], SlRating.prototype, "handleIsHoveringChange", 1);

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.5AZIVGJ7.js
SlRating.define("sl-rating");

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.G4XIACTT.js
var tab_group_styles_default = i`
  :host {
    --indicator-color: var(--sl-color-primary-600);
    --track-color: var(--sl-color-neutral-200);
    --track-width: 2px;

    display: block;
  }

  .tab-group {
    display: flex;
    border-radius: 0;
  }

  .tab-group__tabs {
    display: flex;
    position: relative;
  }

  .tab-group__indicator {
    position: absolute;
    transition:
      var(--sl-transition-fast) translate ease,
      var(--sl-transition-fast) width ease;
  }

  .tab-group--has-scroll-controls .tab-group__nav-container {
    position: relative;
    padding: 0 var(--sl-spacing-x-large);
  }

  .tab-group__body {
    display: block;
    overflow: auto;
  }

  .tab-group__scroll-button {
    display: flex;
    align-items: center;
    justify-content: center;
    position: absolute;
    top: 0;
    bottom: 0;
    width: var(--sl-spacing-x-large);
  }

  .tab-group__scroll-button--start {
    left: 0;
  }

  .tab-group__scroll-button--end {
    right: 0;
  }

  .tab-group--rtl .tab-group__scroll-button--start {
    left: auto;
    right: 0;
  }

  .tab-group--rtl .tab-group__scroll-button--end {
    left: 0;
    right: auto;
  }

  /*
   * Top
   */

  .tab-group--top {
    flex-direction: column;
  }

  .tab-group--top .tab-group__nav-container {
    order: 1;
  }

  .tab-group--top .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--top .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--top .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-bottom: solid var(--track-width) var(--track-color);
  }

  .tab-group--top .tab-group__indicator {
    bottom: calc(-1 * var(--track-width));
    border-bottom: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--top .tab-group__body {
    order: 2;
  }

  .tab-group--top ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Bottom
   */

  .tab-group--bottom {
    flex-direction: column;
  }

  .tab-group--bottom .tab-group__nav-container {
    order: 2;
  }

  .tab-group--bottom .tab-group__nav {
    display: flex;
    overflow-x: auto;

    /* Hide scrollbar in Firefox */
    scrollbar-width: none;
  }

  /* Hide scrollbar in Chrome/Safari */
  .tab-group--bottom .tab-group__nav::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  .tab-group--bottom .tab-group__tabs {
    flex: 1 1 auto;
    position: relative;
    flex-direction: row;
    border-top: solid var(--track-width) var(--track-color);
  }

  .tab-group--bottom .tab-group__indicator {
    top: calc(-1 * var(--track-width));
    border-top: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--bottom .tab-group__body {
    order: 1;
  }

  .tab-group--bottom ::slotted(sl-tab-panel) {
    --padding: var(--sl-spacing-medium) 0;
  }

  /*
   * Start
   */

  .tab-group--start {
    flex-direction: row;
  }

  .tab-group--start .tab-group__nav-container {
    order: 1;
  }

  .tab-group--start .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-inline-end: solid var(--track-width) var(--track-color);
  }

  .tab-group--start .tab-group__indicator {
    right: calc(-1 * var(--track-width));
    border-right: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--start.tab-group--rtl .tab-group__indicator {
    right: auto;
    left: calc(-1 * var(--track-width));
  }

  .tab-group--start .tab-group__body {
    flex: 1 1 auto;
    order: 2;
  }

  .tab-group--start ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }

  /*
   * End
   */

  .tab-group--end {
    flex-direction: row;
  }

  .tab-group--end .tab-group__nav-container {
    order: 2;
  }

  .tab-group--end .tab-group__tabs {
    flex: 0 0 auto;
    flex-direction: column;
    border-left: solid var(--track-width) var(--track-color);
  }

  .tab-group--end .tab-group__indicator {
    left: calc(-1 * var(--track-width));
    border-inline-start: solid var(--track-width) var(--indicator-color);
  }

  .tab-group--end.tab-group--rtl .tab-group__indicator {
    right: calc(-1 * var(--track-width));
    left: auto;
  }

  .tab-group--end .tab-group__body {
    flex: 1 1 auto;
    order: 1;
  }

  .tab-group--end ::slotted(sl-tab-panel) {
    --padding: 0 var(--sl-spacing-medium);
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.BTENR4BI.js
function getOffset(element, parent) {
  return {
    top: Math.round(element.getBoundingClientRect().top - parent.getBoundingClientRect().top),
    left: Math.round(element.getBoundingClientRect().left - parent.getBoundingClientRect().left)
  };
}
function scrollIntoView(element, container, direction = "vertical", behavior = "smooth") {
  const offset2 = getOffset(element, container);
  const offsetTop = offset2.top + container.scrollTop;
  const offsetLeft = offset2.left + container.scrollLeft;
  const minX = container.scrollLeft;
  const maxX = container.scrollLeft + container.offsetWidth;
  const minY = container.scrollTop;
  const maxY = container.scrollTop + container.offsetHeight;
  if (direction === "horizontal" || direction === "both") {
    if (offsetLeft < minX) {
      container.scrollTo({ left: offsetLeft, behavior });
    } else if (offsetLeft + element.clientWidth > maxX) {
      container.scrollTo({ left: offsetLeft - container.offsetWidth + element.clientWidth, behavior });
    }
  }
  if (direction === "vertical" || direction === "both") {
    if (offsetTop < minY) {
      container.scrollTo({ top: offsetTop, behavior });
    } else if (offsetTop + element.clientHeight > maxY) {
      container.scrollTo({ top: offsetTop - container.offsetHeight + element.clientHeight, behavior });
    }
  }
}

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.6I2T3DLI.js
var icon_button_styles_default = i`
  :host {
    display: inline-block;
    color: var(--sl-color-neutral-600);
  }

  .icon-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
    -webkit-appearance: none;
  }

  .icon-button:hover:not(.icon-button--disabled),
  .icon-button:focus-visible:not(.icon-button--disabled) {
    color: var(--sl-color-primary-600);
  }

  .icon-button:active:not(.icon-button--disabled) {
    color: var(--sl-color-primary-700);
  }

  .icon-button:focus {
    outline: none;
  }

  .icon-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .icon-button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .icon-button__icon {
    pointer-events: none;
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.WQ4LAAP4.js
var SlIconButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasFocus = false;
    this.label = "";
    this.disabled = false;
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick(event) {
    if (this.disabled) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  /** Simulates a click on the icon button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the icon button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the icon button. */
  blur() {
    this.button.blur();
  }
  render() {
    const isLink = this.href ? true : false;
    const tag = isLink ? s4`a` : s4`button`;
    return n5`
      <${tag}
        part="base"
        class=${e8({
      "icon-button": true,
      "icon-button--disabled": !isLink && this.disabled,
      "icon-button--focused": this.hasFocus
    })}
        ?disabled=${o6(isLink ? void 0 : this.disabled)}
        type=${o6(isLink ? void 0 : "button")}
        href=${o6(isLink ? this.href : void 0)}
        target=${o6(isLink ? this.target : void 0)}
        download=${o6(isLink ? this.download : void 0)}
        rel=${o6(isLink && this.target ? "noreferrer noopener" : void 0)}
        role=${o6(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-label="${this.label}"
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @click=${this.handleClick}
      >
        <sl-icon
          class="icon-button__icon"
          name=${o6(this.name)}
          library=${o6(this.library)}
          src=${o6(this.src)}
          aria-hidden="true"
        ></sl-icon>
      </${tag}>
    `;
  }
};
SlIconButton.styles = [component_styles_default, icon_button_styles_default];
SlIconButton.dependencies = { "sl-icon": SlIcon };
__decorateClass([
  e5(".icon-button")
], SlIconButton.prototype, "button", 2);
__decorateClass([
  r6()
], SlIconButton.prototype, "hasFocus", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "name", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "library", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "src", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "href", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "target", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "download", 2);
__decorateClass([
  n4()
], SlIconButton.prototype, "label", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlIconButton.prototype, "disabled", 2);

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ZBVVUYEV.js
var SlTabGroup = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.tabs = [];
    this.panels = [];
    this.hasScrollControls = false;
    this.placement = "top";
    this.activation = "auto";
    this.noScrollControls = false;
  }
  connectedCallback() {
    const whenAllDefined = Promise.all([
      customElements.whenDefined("sl-tab"),
      customElements.whenDefined("sl-tab-panel")
    ]);
    super.connectedCallback();
    this.resizeObserver = new ResizeObserver(() => {
      this.repositionIndicator();
      this.updateScrollControls();
    });
    this.mutationObserver = new MutationObserver((mutations) => {
      if (mutations.some((m3) => !["aria-labelledby", "aria-controls"].includes(m3.attributeName))) {
        setTimeout(() => this.setAriaLabels());
      }
      if (mutations.some((m3) => m3.attributeName === "disabled")) {
        this.syncTabsAndPanels();
      }
    });
    this.updateComplete.then(() => {
      this.syncTabsAndPanels();
      this.mutationObserver.observe(this, { attributes: true, childList: true, subtree: true });
      this.resizeObserver.observe(this.nav);
      whenAllDefined.then(() => {
        const intersectionObserver = new IntersectionObserver((entries, observer) => {
          var _a6;
          if (entries[0].intersectionRatio > 0) {
            this.setAriaLabels();
            this.setActiveTab((_a6 = this.getActiveTab()) != null ? _a6 : this.tabs[0], { emitEvents: false });
            observer.unobserve(entries[0].target);
          }
        });
        intersectionObserver.observe(this.tabGroup);
      });
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.mutationObserver.disconnect();
    this.resizeObserver.unobserve(this.nav);
  }
  getAllTabs(options = { includeDisabled: true }) {
    const slot = this.shadowRoot.querySelector('slot[name="nav"]');
    return [...slot.assignedElements()].filter((el) => {
      return options.includeDisabled ? el.tagName.toLowerCase() === "sl-tab" : el.tagName.toLowerCase() === "sl-tab" && !el.disabled;
    });
  }
  getAllPanels() {
    return [...this.body.assignedElements()].filter((el) => el.tagName.toLowerCase() === "sl-tab-panel");
  }
  getActiveTab() {
    return this.tabs.find((el) => el.active);
  }
  handleClick(event) {
    const target = event.target;
    const tab = target.closest("sl-tab");
    const tabGroup = tab == null ? void 0 : tab.closest("sl-tab-group");
    if (tabGroup !== this) {
      return;
    }
    if (tab !== null) {
      this.setActiveTab(tab, { scrollBehavior: "smooth" });
    }
  }
  handleKeyDown(event) {
    const target = event.target;
    const tab = target.closest("sl-tab");
    const tabGroup = tab == null ? void 0 : tab.closest("sl-tab-group");
    if (tabGroup !== this) {
      return;
    }
    if (["Enter", " "].includes(event.key)) {
      if (tab !== null) {
        this.setActiveTab(tab, { scrollBehavior: "smooth" });
        event.preventDefault();
      }
    }
    if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
      const activeEl = this.tabs.find((t7) => t7.matches(":focus"));
      const isRtl = this.localize.dir() === "rtl";
      if ((activeEl == null ? void 0 : activeEl.tagName.toLowerCase()) === "sl-tab") {
        let index = this.tabs.indexOf(activeEl);
        if (event.key === "Home") {
          index = 0;
        } else if (event.key === "End") {
          index = this.tabs.length - 1;
        } else if (["top", "bottom"].includes(this.placement) && event.key === (isRtl ? "ArrowRight" : "ArrowLeft") || ["start", "end"].includes(this.placement) && event.key === "ArrowUp") {
          index--;
        } else if (["top", "bottom"].includes(this.placement) && event.key === (isRtl ? "ArrowLeft" : "ArrowRight") || ["start", "end"].includes(this.placement) && event.key === "ArrowDown") {
          index++;
        }
        if (index < 0) {
          index = this.tabs.length - 1;
        }
        if (index > this.tabs.length - 1) {
          index = 0;
        }
        this.tabs[index].focus({ preventScroll: true });
        if (this.activation === "auto") {
          this.setActiveTab(this.tabs[index], { scrollBehavior: "smooth" });
        }
        if (["top", "bottom"].includes(this.placement)) {
          scrollIntoView(this.tabs[index], this.nav, "horizontal");
        }
        event.preventDefault();
      }
    }
  }
  handleScrollToStart() {
    this.nav.scroll({
      left: this.localize.dir() === "rtl" ? this.nav.scrollLeft + this.nav.clientWidth : this.nav.scrollLeft - this.nav.clientWidth,
      behavior: "smooth"
    });
  }
  handleScrollToEnd() {
    this.nav.scroll({
      left: this.localize.dir() === "rtl" ? this.nav.scrollLeft - this.nav.clientWidth : this.nav.scrollLeft + this.nav.clientWidth,
      behavior: "smooth"
    });
  }
  setActiveTab(tab, options) {
    options = __spreadValues({
      emitEvents: true,
      scrollBehavior: "auto"
    }, options);
    if (tab !== this.activeTab && !tab.disabled) {
      const previousTab = this.activeTab;
      this.activeTab = tab;
      this.tabs.forEach((el) => el.active = el === this.activeTab);
      this.panels.forEach((el) => {
        var _a6;
        return el.active = el.name === ((_a6 = this.activeTab) == null ? void 0 : _a6.panel);
      });
      this.syncIndicator();
      if (["top", "bottom"].includes(this.placement)) {
        scrollIntoView(this.activeTab, this.nav, "horizontal", options.scrollBehavior);
      }
      if (options.emitEvents) {
        if (previousTab) {
          this.emit("sl-tab-hide", { detail: { name: previousTab.panel } });
        }
        this.emit("sl-tab-show", { detail: { name: this.activeTab.panel } });
      }
    }
  }
  setAriaLabels() {
    this.tabs.forEach((tab) => {
      const panel = this.panels.find((el) => el.name === tab.panel);
      if (panel) {
        tab.setAttribute("aria-controls", panel.getAttribute("id"));
        panel.setAttribute("aria-labelledby", tab.getAttribute("id"));
      }
    });
  }
  repositionIndicator() {
    const currentTab = this.getActiveTab();
    if (!currentTab) {
      return;
    }
    const width = currentTab.clientWidth;
    const height = currentTab.clientHeight;
    const isRtl = this.localize.dir() === "rtl";
    const allTabs = this.getAllTabs();
    const precedingTabs = allTabs.slice(0, allTabs.indexOf(currentTab));
    const offset2 = precedingTabs.reduce(
      (previous, current) => ({
        left: previous.left + current.clientWidth,
        top: previous.top + current.clientHeight
      }),
      { left: 0, top: 0 }
    );
    switch (this.placement) {
      case "top":
      case "bottom":
        this.indicator.style.width = `${width}px`;
        this.indicator.style.height = "auto";
        this.indicator.style.translate = isRtl ? `${-1 * offset2.left}px` : `${offset2.left}px`;
        break;
      case "start":
      case "end":
        this.indicator.style.width = "auto";
        this.indicator.style.height = `${height}px`;
        this.indicator.style.translate = `0 ${offset2.top}px`;
        break;
    }
  }
  // This stores tabs and panels so we can refer to a cache instead of calling querySelectorAll() multiple times.
  syncTabsAndPanels() {
    this.tabs = this.getAllTabs({ includeDisabled: false });
    this.panels = this.getAllPanels();
    this.syncIndicator();
    this.updateComplete.then(() => this.updateScrollControls());
  }
  updateScrollControls() {
    if (this.noScrollControls) {
      this.hasScrollControls = false;
    } else {
      this.hasScrollControls = ["top", "bottom"].includes(this.placement) && this.nav.scrollWidth > this.nav.clientWidth + 1;
    }
  }
  syncIndicator() {
    const tab = this.getActiveTab();
    if (tab) {
      this.indicator.style.display = "block";
      this.repositionIndicator();
    } else {
      this.indicator.style.display = "none";
    }
  }
  /** Shows the specified tab panel. */
  show(panel) {
    const tab = this.tabs.find((el) => el.panel === panel);
    if (tab) {
      this.setActiveTab(tab, { scrollBehavior: "smooth" });
    }
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    return x`
      <div
        part="base"
        class=${e8({
      "tab-group": true,
      "tab-group--top": this.placement === "top",
      "tab-group--bottom": this.placement === "bottom",
      "tab-group--start": this.placement === "start",
      "tab-group--end": this.placement === "end",
      "tab-group--rtl": this.localize.dir() === "rtl",
      "tab-group--has-scroll-controls": this.hasScrollControls
    })}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
      >
        <div class="tab-group__nav-container" part="nav">
          ${this.hasScrollControls ? x`
                <sl-icon-button
                  part="scroll-button scroll-button--start"
                  exportparts="base:scroll-button__base"
                  class="tab-group__scroll-button tab-group__scroll-button--start"
                  name=${isRtl ? "chevron-right" : "chevron-left"}
                  library="system"
                  label=${this.localize.term("scrollToStart")}
                  @click=${this.handleScrollToStart}
                ></sl-icon-button>
              ` : ""}

          <div class="tab-group__nav">
            <div part="tabs" class="tab-group__tabs" role="tablist">
              <div part="active-tab-indicator" class="tab-group__indicator"></div>
              <slot name="nav" @slotchange=${this.syncTabsAndPanels}></slot>
            </div>
          </div>

          ${this.hasScrollControls ? x`
                <sl-icon-button
                  part="scroll-button scroll-button--end"
                  exportparts="base:scroll-button__base"
                  class="tab-group__scroll-button tab-group__scroll-button--end"
                  name=${isRtl ? "chevron-left" : "chevron-right"}
                  library="system"
                  label=${this.localize.term("scrollToEnd")}
                  @click=${this.handleScrollToEnd}
                ></sl-icon-button>
              ` : ""}
        </div>

        <slot part="body" class="tab-group__body" @slotchange=${this.syncTabsAndPanels}></slot>
      </div>
    `;
  }
};
SlTabGroup.styles = [component_styles_default, tab_group_styles_default];
SlTabGroup.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass([
  e5(".tab-group")
], SlTabGroup.prototype, "tabGroup", 2);
__decorateClass([
  e5(".tab-group__body")
], SlTabGroup.prototype, "body", 2);
__decorateClass([
  e5(".tab-group__nav")
], SlTabGroup.prototype, "nav", 2);
__decorateClass([
  e5(".tab-group__indicator")
], SlTabGroup.prototype, "indicator", 2);
__decorateClass([
  r6()
], SlTabGroup.prototype, "hasScrollControls", 2);
__decorateClass([
  n4()
], SlTabGroup.prototype, "placement", 2);
__decorateClass([
  n4()
], SlTabGroup.prototype, "activation", 2);
__decorateClass([
  n4({ attribute: "no-scroll-controls", type: Boolean })
], SlTabGroup.prototype, "noScrollControls", 2);
__decorateClass([
  watch("noScrollControls", { waitUntilFirstUpdate: true })
], SlTabGroup.prototype, "updateScrollControls", 1);
__decorateClass([
  watch("placement", { waitUntilFirstUpdate: true })
], SlTabGroup.prototype, "syncIndicator", 1);

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.PYWN6ES2.js
SlTabGroup.define("sl-tab-group");

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.BQSEJD7X.js
var tab_panel_styles_default = i`
  :host {
    --padding: 0;

    display: none;
  }

  :host([active]) {
    display: block;
  }

  .tab-panel {
    display: block;
    padding: var(--padding);
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.JBJQHIXK.js
var id = 0;
var SlTabPanel = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.attrId = ++id;
    this.componentId = `sl-tab-panel-${this.attrId}`;
    this.name = "";
    this.active = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.id = this.id.length > 0 ? this.id : this.componentId;
    this.setAttribute("role", "tabpanel");
  }
  handleActiveChange() {
    this.setAttribute("aria-hidden", this.active ? "false" : "true");
  }
  render() {
    return x`
      <slot
        part="base"
        class=${e8({
      "tab-panel": true,
      "tab-panel--active": this.active
    })}
      ></slot>
    `;
  }
};
SlTabPanel.styles = [component_styles_default, tab_panel_styles_default];
__decorateClass([
  n4({ reflect: true })
], SlTabPanel.prototype, "name", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlTabPanel.prototype, "active", 2);
__decorateClass([
  watch("active")
], SlTabPanel.prototype, "handleActiveChange", 1);

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7SESWKJL.js
SlTabPanel.define("sl-tab-panel");

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.P6JE66YJ.js
var tab_styles_default = i`
  :host {
    display: inline-block;
  }

  .tab {
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    border-radius: var(--sl-border-radius-medium);
    color: var(--sl-color-neutral-600);
    padding: var(--sl-spacing-medium) var(--sl-spacing-large);
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
    cursor: pointer;
    transition:
      var(--transition-speed) box-shadow,
      var(--transition-speed) color;
  }

  .tab:hover:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab:focus {
    outline: none;
  }

  .tab:focus-visible:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: calc(-1 * var(--sl-focus-ring-width) - var(--sl-focus-ring-offset));
  }

  .tab.tab--active:not(.tab--disabled) {
    color: var(--sl-color-primary-600);
  }

  .tab.tab--closable {
    padding-inline-end: var(--sl-spacing-small);
  }

  .tab.tab--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .tab__close-button {
    font-size: var(--sl-font-size-small);
    margin-inline-start: var(--sl-spacing-small);
  }

  .tab__close-button::part(base) {
    padding: var(--sl-spacing-3x-small);
  }

  @media (forced-colors: active) {
    .tab.tab--active:not(.tab--disabled) {
      outline: solid 1px transparent;
      outline-offset: -3px;
    }
  }
`;

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.K4TPGPP3.js
var id2 = 0;
var SlTab = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.attrId = ++id2;
    this.componentId = `sl-tab-${this.attrId}`;
    this.panel = "";
    this.active = false;
    this.closable = false;
    this.disabled = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "tab");
  }
  handleCloseClick(event) {
    event.stopPropagation();
    this.emit("sl-close");
  }
  handleActiveChange() {
    this.setAttribute("aria-selected", this.active ? "true" : "false");
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  /** Sets focus to the tab. */
  focus(options) {
    this.tab.focus(options);
  }
  /** Removes focus from the tab. */
  blur() {
    this.tab.blur();
  }
  render() {
    this.id = this.id.length > 0 ? this.id : this.componentId;
    return x`
      <div
        part="base"
        class=${e8({
      tab: true,
      "tab--active": this.active,
      "tab--closable": this.closable,
      "tab--disabled": this.disabled
    })}
        tabindex=${this.disabled ? "-1" : "0"}
      >
        <slot></slot>
        ${this.closable ? x`
              <sl-icon-button
                part="close-button"
                exportparts="base:close-button__base"
                name="x-lg"
                library="system"
                label=${this.localize.term("close")}
                class="tab__close-button"
                @click=${this.handleCloseClick}
                tabindex="-1"
              ></sl-icon-button>
            ` : ""}
      </div>
    `;
  }
};
SlTab.styles = [component_styles_default, tab_styles_default];
SlTab.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass([
  e5(".tab")
], SlTab.prototype, "tab", 2);
__decorateClass([
  n4({ reflect: true })
], SlTab.prototype, "panel", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlTab.prototype, "active", 2);
__decorateClass([
  n4({ type: Boolean })
], SlTab.prototype, "closable", 2);
__decorateClass([
  n4({ type: Boolean, reflect: true })
], SlTab.prototype, "disabled", 2);
__decorateClass([
  watch("active")
], SlTab.prototype, "handleActiveChange", 1);
__decorateClass([
  watch("disabled")
], SlTab.prototype, "handleDisabledChange", 1);

// node_modules/.pnpm/@shoelace-style+shoelace@2.15.0_@types+react@18.3.1/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.DU2ADDTQ.js
SlTab.define("sl-tab");

// main.ts
var import_obsidian2 = require("obsidian");

// io/fileHandler.ts
var FileHandler = class {
  static async updateCanvasNode(node, file, vault) {
    const content = await vault.read(file);
    try {
      const parsed_data = JSON.parse(content);
      for (const elem of parsed_data.nodes) {
        if (elem.id == node.id) {
          delete elem.description;
          delete elem.title;
          if (node.description && node.description != "") {
            elem.description = node.description;
          }
          if (node.title && node.title != "") {
            elem.title = node.title;
          }
          break;
        }
      }
      await vault.modify(file, JSON.stringify(parsed_data));
    } catch (error) {
      console.error(error);
    }
  }
};

// dom/handler.ts
var import_obsidian = require("obsidian");
var _freeSelectionListeners, freeSelectionListeners_fn, _freeNodesClickListeners, freeNodesClickListeners_fn, _freeTitleEditListeners, freeTitleEditListeners_fn, _freeSearchBarListeners, freeSearchBarListeners_fn, _freeSortMenuListeners, freeSortMenuListeners_fn, _freeFilterMenuBadgeListeners, freeFilterMenuBadgeListeners_fn, _toggleSortMenu, toggleSortMenu_fn, _sortItemTemplate, sortItemTemplate_fn, _getFilterSection, getFilterSection_fn, _saveTitle, saveTitle_fn;
var _DOMHandler = class {
  static async populateNodes(nodes) {
    var _a6;
    const body = document.querySelector(".nodes-body");
    if (nodes == null || !body)
      return;
    __privateMethod(_a6 = _DOMHandler, _freeNodesClickListeners, freeNodesClickListeners_fn).call(_a6);
    body.empty();
    for (const node of nodes) {
      const cls = ["node-element"];
      if (node.selected)
        cls.push("node-active");
      const child = createEl("div", {
        text: node.title,
        attr: { class: cls.join(" ") }
      });
      const clickCallback = (event) => {
        node.container.click();
      };
      child.addEventListener("click", clickCallback);
      this.nodes_click_lister_cb.push(() => {
        child.removeEventListener("click", clickCallback);
      });
      body.appendChild(child);
    }
  }
  static showSelectedNode() {
    if (!this.crafty)
      return;
    const node = this.crafty.selectedNode;
    if (!node || this.last_node_id == node.id)
      return;
    __privateMethod(this, _freeSelectionListeners, freeSelectionListeners_fn).call(this);
    const title_container = this.getTitleDisplay();
    const title = title_container.querySelector("span");
    const text_area = this.getTextArea();
    const save_state = this.getSaveState();
    text_area.classList.remove("hidden");
    save_state.classList.remove("hidden");
    if (!title)
      return;
    title_container.classList.remove("hidden");
    title.setText(node.title);
    this.updateTextArea(node.description || "");
  }
  static async showEmptyEdit() {
    __privateMethod(this, _freeSelectionListeners, freeSelectionListeners_fn).call(this);
    const text_area = this.getTextArea();
    const save_state = this.getSaveState();
    text_area.classList.add("hidden");
    save_state.classList.add("hidden");
    _DOMHandler.hideTitle();
  }
  static async showEmptyNodes() {
    const search_bar = this.getSearchBar();
    const nodes_container = this.getNodesContainer();
    const sort_button = this.getSortButton();
    const filter_button = this.getFiltersButton();
    search_bar.classList.add("hidden");
    nodes_container.classList.add("hidden");
    sort_button.classList.add("hidden");
    filter_button.classList.add("hidden");
  }
  static async showNodes() {
    const search_bar = this.getSearchBar();
    const nodes_container = this.getNodesContainer();
    const sort_button = this.getSortButton();
    const filter_button = this.getFiltersButton();
    search_bar.classList.remove("hidden");
    nodes_container.classList.remove("hidden");
    sort_button.classList.remove("hidden");
    filter_button.classList.remove("hidden");
  }
  static hideTitle() {
    const title_display = this.getTitleDisplay();
    const title_input = this.getTitleInput();
    title_display.classList.add("hidden");
    title_input.classList.add("hidden");
  }
  static getTitleDisplay() {
    if (!this.titleDisplay) {
      const element = createEl("div", {
        attr: { class: "title-edit-div" }
      });
      element.createEl("span", {
        attr: { class: "title" }
      });
      const icon_container = element.createEl("span", {
        attr: { class: "edit-icon" }
      });
      (0, import_obsidian.setIcon)(icon_container, "pencil");
      const icon_click_cb = () => {
        const input = _DOMHandler.getTitleInput();
        element.classList.add("hidden");
        input.classList.remove("hidden");
        input.querySelector("input");
        const inner_input = input.querySelector("input");
        if (!inner_input)
          return;
        const span = element.querySelector(
          "span"
        );
        inner_input.value = span.textContent || "";
        inner_input.focus();
      };
      icon_container.addEventListener("click", icon_click_cb);
      this.title_edit_lister_cb.push(() => {
        icon_container.removeEventListener("click", icon_click_cb);
      });
      this.titleDisplay = element;
    }
    return this.titleDisplay;
  }
  static getSaveState() {
    if (!this.save_state) {
      const save_state = createEl("span", {
        text: "Saved",
        attr: { class: "save_state" }
      });
      this.save_state = save_state;
    }
    return this.save_state;
  }
  static updateTextArea(value) {
    if (!this.crafty || !this.crafty.nodeState)
      return;
    if (this.crafty.nodeState.isNodeSame)
      return;
    const text_area = this.getTextArea();
    text_area.value = value;
  }
  static getTextArea() {
    if (!this.textArea) {
      const element = createEl("textarea", {
        attr: { class: "description-input" }
      });
      this.textArea = element;
    }
    __privateMethod(this, _freeSelectionListeners, freeSelectionListeners_fn).call(this);
    const inputChangeCallback = (0, import_obsidian.debounce)(
      async (t7) => {
        if (!this.crafty || !this.crafty.selectedNode || !this.textArea)
          return;
        const node = this.crafty.selectedNode;
        const file = this.crafty.currentFile;
        const vault = this.crafty.vault;
        const save_state = _DOMHandler.getSaveState();
        save_state.setText("Saving...");
        node.description = this.textArea.value;
        await FileHandler.updateCanvasNode(node, file, vault);
        setTimeout(() => {
          save_state.setText("Saved");
        }, 200);
      },
      1e3,
      true
    );
    this.textArea.addEventListener("input", inputChangeCallback);
    this.selection_listeners_cb.push(() => {
      if (!this.textArea)
        return;
      this.textArea.removeEventListener("input", inputChangeCallback);
    });
    return this.textArea;
  }
  static getSearchBar() {
    if (!this.search_bar) {
      const search_bar = createEl("input", {
        attr: { class: "searchBar-input" }
      });
      search_bar.placeholder = "Search";
      const search_change_cb = (0, import_obsidian.debounce)(() => {
        if (!this.crafty || !this.crafty.nodeState)
          return;
        const node_state = this.crafty.nodeState;
        node_state.setSearchWord(search_bar.value);
      }, 1e3);
      search_bar.addEventListener("input", search_change_cb);
      this.searchbar_lister_cb.push(() => {
        search_bar.removeEventListener("input", search_change_cb);
      });
      this.search_bar = search_bar;
    }
    return this.search_bar;
  }
  static getSortMenu() {
    if (!this.sort_menu) {
      const menu = createEl("sl-menu", {
        attr: { class: "sort-menu" }
      });
      const selectName = () => {
        if (!this.crafty || !this.crafty.nodeState)
          return;
        this.crafty.nodeState.sortBy("name");
        __privateMethod(this, _toggleSortMenu, toggleSortMenu_fn).call(this);
      };
      const selectCreated = () => {
        if (!this.crafty || !this.crafty.nodeState)
          return;
        this.crafty.nodeState.sortBy("created_at");
        __privateMethod(this, _toggleSortMenu, toggleSortMenu_fn).call(this);
      };
      const selectLastModified = () => {
        if (!this.crafty || !this.crafty.nodeState)
          return;
        this.crafty.nodeState.sortBy("last_modified");
        __privateMethod(this, _toggleSortMenu, toggleSortMenu_fn).call(this);
      };
      const selectAscending = () => {
        if (!this.crafty || !this.crafty.nodeState)
          return;
        this.crafty.nodeState.order("asc");
        __privateMethod(this, _toggleSortMenu, toggleSortMenu_fn).call(this);
      };
      const selectDescending = () => {
        if (!this.crafty || !this.crafty.nodeState)
          return;
        this.crafty.nodeState.order("des");
        __privateMethod(this, _toggleSortMenu, toggleSortMenu_fn).call(this);
      };
      const pick_name = __privateMethod(this, _sortItemTemplate, sortItemTemplate_fn).call(this, "Name", "g1", "s-name", selectName);
      const pick_created = __privateMethod(this, _sortItemTemplate, sortItemTemplate_fn).call(this, "Created_At", "g1", "s-created", selectCreated);
      const pick_last = __privateMethod(this, _sortItemTemplate, sortItemTemplate_fn).call(this, "Last_Modified", "g1", "s-last", selectLastModified);
      const pick_asc = __privateMethod(this, _sortItemTemplate, sortItemTemplate_fn).call(this, "Ascending", "g2", "s-asc", selectAscending);
      const pick_desc = __privateMethod(this, _sortItemTemplate, sortItemTemplate_fn).call(this, "Descending", "g2", "s-desc", selectDescending);
      const divider = createEl("sl-divider", {});
      menu.appendChild(pick_name);
      menu.appendChild(pick_created);
      menu.appendChild(pick_last);
      menu.appendChild(divider);
      menu.appendChild(pick_asc);
      menu.appendChild(pick_desc);
      this.sort_menu = menu;
    }
    return this.sort_menu;
  }
  static getSortButton() {
    if (!this.sort_button) {
      const sort_button = createEl("sl-dropdown", {
        attr: {
          class: "sort-button-container",
          distance: "-40",
          skidding: "-10"
        }
      });
      const button = createEl("button", {
        attr: { class: "sort-button", slot: "trigger" }
      });
      const text = createEl("span", {
        attr: { class: "sort-button-large sb-text" }
      });
      const logo = createEl("div", {});
      (0, import_obsidian.setIcon)(logo, "arrow-down-up");
      button.appendChild(logo);
      button.appendChild(text);
      sort_button.appendChild(button);
      sort_button.appendChild(this.getSortMenu());
      this.sort_button = sort_button;
    }
    return this.sort_button;
  }
  static getNodesContainer() {
    if (!this.nodes_container) {
      const nodes_container = createEl("div", {
        attr: { class: "nodes-container" }
      });
      nodes_container.createEl("div", {
        attr: { class: "nodes-body" }
      });
      this.nodes_container = nodes_container;
    }
    return this.nodes_container;
  }
  static getFilterMenu() {
    if (!this.filter_menu) {
      __privateMethod(this, _freeFilterMenuBadgeListeners, freeFilterMenuBadgeListeners_fn).call(this);
      const filter_menu = createEl("sl-menu", {
        attr: {
          class: "filter-menu"
        }
      });
      const general = createEl("div", {
        attr: {
          class: "filter-menu-section"
        }
      });
      const general_title = createEl("span", {});
      general_title.setText("General");
      general.appendChild(general_title);
      general.appendChild(__privateMethod(this, _getFilterSection, getFilterSection_fn).call(this, "General"));
      const document2 = createEl("div", {
        attr: {
          class: "filter-menu-section"
        }
      });
      const document_title = createEl("span", {});
      document_title.setText("Documents");
      document2.appendChild(document_title);
      document2.appendChild(__privateMethod(this, _getFilterSection, getFilterSection_fn).call(this, "Document"));
      const image = createEl("div", {
        attr: {
          class: "filter-menu-section"
        }
      });
      const image_title = createEl("span", {});
      image_title.setText("Image");
      image.appendChild(image_title);
      image.appendChild(__privateMethod(this, _getFilterSection, getFilterSection_fn).call(this, "Image"));
      const audio = createEl("div", {
        attr: {
          class: "filter-menu-section"
        }
      });
      const audio_title = createEl("span", {});
      audio_title.setText("Audio");
      audio.appendChild(audio_title);
      audio.appendChild(__privateMethod(this, _getFilterSection, getFilterSection_fn).call(this, "Audio"));
      const video = createEl("div", {
        attr: {
          class: "filter-menu-section"
        }
      });
      const video_title = createEl("span", {});
      video_title.setText("Video");
      video.appendChild(video_title);
      video.appendChild(__privateMethod(this, _getFilterSection, getFilterSection_fn).call(this, "Image"));
      filter_menu.appendChild(general);
      filter_menu.appendChild(document2);
      filter_menu.appendChild(image);
      filter_menu.appendChild(audio);
      filter_menu.appendChild(video);
      this.filter_menu = filter_menu;
    }
    return this.filter_menu;
  }
  static getFiltersButton() {
    if (!this.filter_button) {
      const filter_button = createEl("sl-dropdown", {
        attr: {
          class: "",
          distance: "-40",
          skidding: "-10"
        }
      });
      const expand_button = createEl("button", {
        attr: { class: "filters-button", slot: "trigger" }
      });
      const logo_container = createEl("div", {});
      (0, import_obsidian.setIcon)(logo_container, "plus");
      const button_text = createEl("span");
      button_text.setText("Filter");
      expand_button.appendChild(logo_container);
      expand_button.appendChild(button_text);
      filter_button.appendChild(expand_button);
      filter_button.appendChild(this.getFilterMenu());
      this.filter_button = filter_button;
    }
    return this.filter_button;
  }
  static getFiltersDisplay() {
    if (!this.filters_display) {
      const filters_display = createEl("div", {
        attr: { class: "filters_display" }
      });
      let filters = [];
      if (this.crafty && this.crafty.nodeFilterState) {
        filters = this.crafty.nodeFilterState.allFilters;
      }
      for (const el of filters) {
        const badge = createEl("div", {
          attr: {
            class: "filter-menu-badge-display"
          }
        });
        const badge_span = createEl("span", {});
        badge_span.setText(el.title);
        badge.appendChild(badge_span);
        if (el.isActive)
          badge.classList.add("badge-display-active");
        filters_display.appendChild(badge);
      }
      this.filters_display = filters_display;
    }
    return this.filters_display;
  }
  static getFiltersContainer() {
    if (!this.filters_container) {
      const container = createEl("div", {
        attr: {
          class: "filters-container"
        }
      });
      container.appendChild(this.getFiltersDisplay());
      container.appendChild(this.getFiltersButton());
      this.filters_container = container;
    }
    return this.filters_container;
  }
  static setCraftyInstance(crafty) {
    this.crafty = crafty;
  }
  static getTitleInput() {
    if (!this.titleInput) {
      const element = createEl("div", {
        attr: { class: "title-edit-div hidden" }
      });
      const input = element.createEl("input", {
        attr: { class: "title-input" }
      });
      const input_focus_lost_cb = async () => {
        __privateMethod(this, _saveTitle, saveTitle_fn).call(this, element, input);
      };
      const input_enter_cb = async (ev) => {
        if (ev.key == "Enter") {
          __privateMethod(this, _saveTitle, saveTitle_fn).call(this, element, input);
        }
      };
      input.addEventListener("focusout", input_focus_lost_cb);
      input.addEventListener("keydown", input_enter_cb);
      this.title_edit_lister_cb.push(() => {
        input.removeEventListener("keydown", input_enter_cb);
      });
      this.title_edit_lister_cb.push(() => {
        input.removeEventListener("focusout", input_focus_lost_cb);
      });
      this.titleInput = element;
    }
    return this.titleInput;
  }
  static free() {
    __privateMethod(this, _freeNodesClickListeners, freeNodesClickListeners_fn).call(this);
    __privateMethod(this, _freeSelectionListeners, freeSelectionListeners_fn).call(this);
    __privateMethod(this, _freeTitleEditListeners, freeTitleEditListeners_fn).call(this);
    __privateMethod(this, _freeSearchBarListeners, freeSearchBarListeners_fn).call(this);
    __privateMethod(this, _freeSortMenuListeners, freeSortMenuListeners_fn).call(this);
    __privateMethod(this, _freeFilterMenuBadgeListeners, freeFilterMenuBadgeListeners_fn).call(this);
  }
};
var DOMHandler = _DOMHandler;
_freeSelectionListeners = new WeakSet();
freeSelectionListeners_fn = function() {
  let callback = this.selection_listeners_cb.pop();
  while (callback) {
    callback();
    callback = this.selection_listeners_cb.pop();
  }
};
_freeNodesClickListeners = new WeakSet();
freeNodesClickListeners_fn = function() {
  let callback = this.nodes_click_lister_cb.pop();
  while (callback) {
    callback();
    callback = this.nodes_click_lister_cb.pop();
  }
};
_freeTitleEditListeners = new WeakSet();
freeTitleEditListeners_fn = function() {
  let callback = this.title_edit_lister_cb.pop();
  while (callback) {
    callback();
    callback = this.title_edit_lister_cb.pop();
  }
};
_freeSearchBarListeners = new WeakSet();
freeSearchBarListeners_fn = function() {
  let callback = this.searchbar_lister_cb.pop();
  while (callback) {
    callback();
    callback = this.searchbar_lister_cb.pop();
  }
};
_freeSortMenuListeners = new WeakSet();
freeSortMenuListeners_fn = function() {
  let callback = this.sort_menu_lister_cb.pop();
  while (callback) {
    callback();
    callback = this.sort_menu_lister_cb.pop();
  }
};
_freeFilterMenuBadgeListeners = new WeakSet();
freeFilterMenuBadgeListeners_fn = function() {
  let callback = this.filter_menu_badge_lister_cb.pop();
  while (callback) {
    callback();
    callback = this.filter_menu_badge_lister_cb.pop();
  }
};
_toggleSortMenu = new WeakSet();
toggleSortMenu_fn = function() {
  const sort_button = this.getSortButton();
  const attributes_name = sort_button.getAttributeNames();
  if (attributes_name.includes("open"))
    sort_button.removeAttribute("open");
  else
    sort_button.setAttr("open", true);
};
_sortItemTemplate = new WeakSet();
sortItemTemplate_fn = function(title, groupe, check_marker, callback) {
  const container = createEl("div", {
    attr: { class: `sort-item ` }
  });
  const item = createEl("div", {});
  item.setText(title);
  const check_logo = createEl("div", {
    attr: { class: `${groupe} sort-check ${check_marker}` }
  });
  (0, import_obsidian.setIcon)(check_logo, "check");
  container.addEventListener("click", callback);
  this.sort_menu_lister_cb.push(() => {
    container.removeEventListener("click", callback);
  });
  container.appendChild(check_logo);
  container.appendChild(item);
  return container;
};
_getFilterSection = new WeakSet();
getFilterSection_fn = function(group) {
  const container = createEl("div", {
    attr: {
      class: "filter-menu-badge-container"
    }
  });
  let filters = [];
  switch (group) {
    case "Document":
      if (this.crafty && this.crafty.nodeFilterState) {
        filters = this.crafty.nodeFilterState.getFilterByGroup(
          "Document"
        );
      }
      break;
    case "Image":
      if (this.crafty && this.crafty.nodeFilterState) {
        filters = this.crafty.nodeFilterState.getFilterByGroup("Image");
      }
      break;
    case "Audio":
      if (this.crafty && this.crafty.nodeFilterState) {
        filters = this.crafty.nodeFilterState.getFilterByGroup("Audio");
      }
      break;
    case "Video":
      if (this.crafty && this.crafty.nodeFilterState) {
        filters = this.crafty.nodeFilterState.getFilterByGroup("Video");
      }
      break;
    case "General":
      if (this.crafty && this.crafty.nodeFilterState) {
        filters = this.crafty.nodeFilterState.getFilterByGroup("General");
      }
      break;
    default:
      break;
  }
  for (const el of filters) {
    const badge = createEl("div", {
      attr: {
        class: "filter-menu-badge"
      }
    });
    const badge_span = createEl("span", {});
    badge_span.setText(el.title);
    badge.appendChild(badge_span);
    const badge_click_cb = () => {
      if (badge.classList.contains("badge-active")) {
        if (this.crafty && this.crafty.nodeFilterState) {
          this.crafty.nodeFilterState.removeFilter(
            el.title
          );
        }
        badge.classList.remove("badge-active");
      } else {
        if (this.crafty && this.crafty.nodeFilterState) {
          this.crafty.nodeFilterState.addFilter(
            el.title
          );
        }
        badge.classList.add("badge-active");
      }
    };
    badge.addEventListener("click", badge_click_cb);
    this.filter_menu_badge_lister_cb.push(() => {
      badge.removeEventListener("click", badge_click_cb);
    });
    container.appendChild(badge);
  }
  return container;
};
_saveTitle = new WeakSet();
saveTitle_fn = async function(element, input) {
  const display = _DOMHandler.getTitleDisplay();
  element.classList.add("hidden");
  display.classList.remove("hidden");
  if (!this.crafty || !this.crafty.selectedNode || !this.textArea)
    return;
  const node = this.crafty.selectedNode;
  const file = this.crafty.currentFile;
  const vault = this.crafty.vault;
  node.title = input.value;
  await FileHandler.updateCanvasNode(node, file, vault);
};
__privateAdd(DOMHandler, _freeSelectionListeners);
__privateAdd(DOMHandler, _freeNodesClickListeners);
__privateAdd(DOMHandler, _freeTitleEditListeners);
__privateAdd(DOMHandler, _freeSearchBarListeners);
__privateAdd(DOMHandler, _freeSortMenuListeners);
__privateAdd(DOMHandler, _freeFilterMenuBadgeListeners);
__privateAdd(DOMHandler, _toggleSortMenu);
__privateAdd(DOMHandler, _sortItemTemplate);
__privateAdd(DOMHandler, _getFilterSection);
__privateAdd(DOMHandler, _saveTitle);
DOMHandler.selection_listeners_cb = [];
DOMHandler.nodes_click_lister_cb = [];
DOMHandler.title_edit_lister_cb = [];
DOMHandler.searchbar_lister_cb = [];
DOMHandler.sort_menu_lister_cb = [];
DOMHandler.filter_menu_badge_lister_cb = [];
DOMHandler.last_node_id = "";
DOMHandler.titleInput = null;
DOMHandler.titleDisplay = null;
DOMHandler.textArea = null;
DOMHandler.save_state = null;
DOMHandler.search_bar = null;
DOMHandler.nodes_container = null;
DOMHandler.filters_container = null;
DOMHandler.filters_display = null;
DOMHandler.sort_button = null;
DOMHandler.filter_button = null;
DOMHandler.sort_menu = null;
DOMHandler.filter_menu = null;

// main.ts
var import_fs = require("fs");

// nodes/nodes.ts
var NodeFilter = class {
  constructor(group, type) {
    this.active = false;
    this._group = group;
    this._title = type == "" ? "default" : type;
    this._type = type;
  }
  enable() {
    this.active = true;
  }
  disable() {
    this.active = false;
  }
  get group() {
    return this._group;
  }
  get title() {
    return this._title;
  }
  get type() {
    return this._type;
  }
  get isActive() {
    return this.active;
  }
};
var FILE_FORMAT = {
  Audio: {
    flac: "flac",
    m4a: "m4a",
    mp3: "mp3",
    ogg: "ogg",
    wav: "wav",
    webm: "webm",
    "3gp": "3gp"
  },
  Image: {
    avif: "avif",
    bmp: "bmp",
    gif: "gif",
    jpeg: "jpeg",
    jpg: "jpg",
    png: "png",
    svg: "svg",
    webp: "webp"
  },
  Video: { mkv: "mkv", mov: "mov", mp4: "mp4", ogv: "ogv", webm: "webm" },
  Document: { canvas: "canvas", md: "md", pdf: "pdf", json: "json" },
  General: {
    link: "link",
    text: "text",
    group: "group",
    video: "video",
    audio: "audio",
    image: "image"
  }
};
var _root, _size, _increaseSize, increaseSize_fn, _decreaseSize, decreaseSize_fn, _addNode, addNode_fn, _splitPart, splitPart_fn, _addSingle, addSingle_fn, _removeNode, removeNode_fn, _removeR, removeR_fn, _searchR, searchR_fn, _prefixSearchR, prefixSearchR_fn, _findSimilarR, findSimilarR_fn, _lcs, lcs_fn, _clearR, clearR_fn;
var NodesExplorer = class {
  constructor() {
    __privateAdd(this, _increaseSize);
    __privateAdd(this, _decreaseSize);
    __privateAdd(this, _addNode);
    __privateAdd(this, _splitPart);
    __privateAdd(this, _addSingle);
    __privateAdd(this, _removeNode);
    __privateAdd(this, _removeR);
    __privateAdd(this, _searchR);
    __privateAdd(this, _prefixSearchR);
    __privateAdd(this, _findSimilarR);
    __privateAdd(this, _lcs);
    __privateAdd(this, _clearR);
    __privateAdd(this, _root, {});
    __privateAdd(this, _size, 0);
  }
  add(node) {
    for (const word of __privateMethod(this, _splitPart, splitPart_fn).call(this, node.title)) {
      __privateMethod(this, _addSingle, addSingle_fn).call(this, word, node);
    }
  }
  remove(node) {
    for (const word of __privateMethod(this, _splitPart, splitPart_fn).call(this, node.title)) {
      __privateMethod(this, _removeR, removeR_fn).call(this, word, 0, __privateGet(this, _root), {}, 0, node.id);
    }
    return null;
  }
  search(word) {
    return __privateMethod(this, _searchR, searchR_fn).call(this, word, 0, __privateGet(this, _root));
  }
  prefixSearch(word) {
    const res = [];
    __privateMethod(this, _prefixSearchR, prefixSearchR_fn).call(this, word, 0, __privateGet(this, _root), res);
    return res;
  }
  findSimilar(word, precision) {
    word = word.toLowerCase();
    const res = [];
    const n7 = word.length;
    const currentRow = new Array(n7 + 1).fill(0);
    const keys = Object.keys(__privateGet(this, _root));
    for (const key of keys) {
      __privateMethod(this, _findSimilarR, findSimilarR_fn).call(
        this,
        //@ts-ignore
        __privateGet(this, _root)[key],
        key,
        word,
        currentRow,
        res,
        precision
      );
    }
    res.sort((a4, b3) => a4[1] - b3[1]);
    return res.filter((val) => {
      const lcs_ration = __privateMethod(this, _lcs, lcs_fn).call(this, word, val[0].title.toLowerCase()) / Math.max(val[0].title.length, word.length);
      return lcs_ration > 0.4;
    }).map((val) => val[0]);
  }
  clear() {
    __privateMethod(this, _clearR, clearR_fn).call(this, __privateGet(this, _root));
    __privateSet(this, _size, 0);
  }
  get size() {
    return __privateGet(this, _size);
  }
};
_root = new WeakMap();
_size = new WeakMap();
_increaseSize = new WeakSet();
increaseSize_fn = function() {
  __privateWrapper(this, _size)._++;
};
_decreaseSize = new WeakSet();
decreaseSize_fn = function() {
  if (__privateGet(this, _size) > 0)
    __privateWrapper(this, _size)._--;
};
_addNode = new WeakSet();
addNode_fn = function(pos, node) {
  let arr = pos["end"];
  if (!arr) {
    arr = [];
    pos["end"] = arr;
  }
  for (let i6 = 0; i6 < arr.length; i6++) {
    if (arr[i6].id == node.id) {
      arr[i6] = node;
      return;
    }
  }
  arr.push(node);
  __privateMethod(this, _increaseSize, increaseSize_fn).call(this);
};
_splitPart = new WeakSet();
splitPart_fn = function(word) {
  const result = [];
  const len = word.length;
  for (let idx = 0; idx < len; idx++) {
    result.push(word.substring(len - idx - 1, len));
  }
  return result;
};
_addSingle = new WeakSet();
addSingle_fn = function(title, node) {
  title = title.toLowerCase();
  let current = __privateGet(this, _root);
  for (let idx = 0; idx < title.length; idx++) {
    const char = title[idx];
    if (current[char])
      current = current[char];
    else {
      current[char] = {};
      current = current[char];
    }
  }
  __privateMethod(this, _addNode, addNode_fn).call(this, current, node);
};
_removeNode = new WeakSet();
removeNode_fn = function(arr, id3) {
  const n7 = arr.length;
  if (!id3) {
    while (arr.length > 0)
      arr.pop();
    return;
  }
  for (let i6 = 0; i6 < n7; i6++) {
    if (id3 == arr[i6].id) {
      [arr[i6]] = [arr[n7 - 1]];
      arr.pop();
    }
  }
};
_removeR = new WeakSet();
removeR_fn = function(word, idx, root, last, last_idx, id3) {
  if (idx >= word.length) {
    if (!root)
      return;
    const arr = root["end"];
    if (!arr)
      return;
    __privateMethod(this, _removeNode, removeNode_fn).call(this, arr, id3);
    if (arr.length == 0) {
      delete root["end"];
      const keys2 = Object.keys(root);
      if (keys2.length == 0)
        delete last[word[last_idx]];
    }
  }
  if (!root)
    return;
  const next = root[word[idx]];
  const keys = Object.keys(root);
  let len = keys.length;
  if (keys.includes("end"))
    len--;
  if (len > 1) {
    last = root;
    last_idx = idx;
  }
  __privateMethod(this, _removeR, removeR_fn).call(this, word, idx + 1, next, root, last_idx, id3);
};
_searchR = new WeakSet();
searchR_fn = function(word, idx, root) {
  word = word.toLowerCase();
  if (idx >= word.length) {
    if (!root)
      return [];
    return root["end"] || [];
  }
  if (!root)
    return [];
  const next = root[word[idx]];
  if (!next)
    return [];
  return __privateMethod(this, _searchR, searchR_fn).call(this, word, idx + 1, next);
};
_prefixSearchR = new WeakSet();
prefixSearchR_fn = function(word, idx, root, acc) {
  word = word.toLowerCase();
  if (!root)
    return;
  const keys = Object.keys(root);
  if (idx >= word.length) {
    const nodes = root["end"];
    if (nodes)
      for (const node of nodes)
        acc.push(node);
    for (const key of keys) {
      const next = root[key];
      if (!next)
        return;
      if (key != "end")
        __privateMethod(this, _prefixSearchR, prefixSearchR_fn).call(this, word, idx + 1, next, acc);
    }
  } else {
    const [up, low] = [
      word[idx].toLocaleLowerCase(),
      word[idx].toLocaleUpperCase()
    ];
    const next_lower = root[up];
    const next_upper = root[low];
    if (!next_lower && !next_upper)
      return;
    __privateMethod(this, _prefixSearchR, prefixSearchR_fn).call(this, word, idx + 1, next_lower, acc);
    __privateMethod(this, _prefixSearchR, prefixSearchR_fn).call(this, word, idx + 1, next_upper, acc);
  }
};
_findSimilarR = new WeakSet();
findSimilarR_fn = function(root, letter, word, previousRow, res, precision) {
  word = word.toLowerCase();
  const n7 = word.length;
  const currentRow = new Array(n7 + 1).fill(0);
  currentRow[0] = previousRow[0] + 1;
  let min2 = Infinity;
  for (let i6 = 1; i6 <= n7; i6++) {
    const insertionCost = currentRow[i6 - 1] + 1;
    const deleteCost = previousRow[i6] + 1;
    let replaceCost = previousRow[i6 - 1];
    if (word[i6 - 1] != letter)
      replaceCost++;
    currentRow[i6] = Math.min(insertionCost, deleteCost, replaceCost);
    min2 = Math.min(min2, currentRow[i6]);
  }
  if (currentRow[n7] <= precision) {
    const nodes = root["end"];
    if (nodes && nodes.length > 0) {
      for (const node of nodes)
        res.push([node, currentRow[n7]]);
    }
  }
  if (min2 <= precision) {
    const keys = Object.keys(root);
    for (const key of keys) {
      if (key == "end")
        continue;
      __privateMethod(this, _findSimilarR, findSimilarR_fn).call(
        this,
        //@ts-ignore
        root[key],
        key,
        word,
        currentRow,
        res,
        precision
      );
    }
  }
};
_lcs = new WeakSet();
lcs_fn = function(s1, s22) {
  const n7 = s1.length, m3 = s22.length;
  const dp = new Array(n7 + 1).fill(null).map(() => new Array(m3 + 1).fill(0));
  for (let i6 = n7 - 1; i6 >= 0; i6--) {
    for (let j2 = m3 - 1; j2 >= 0; j2--) {
      if (s1[i6] == s22[j2])
        dp[i6][j2] = 1 + dp[i6 + 1][j2 + 1];
      else
        dp[i6][j2] = Math.max(dp[i6 + 1][j2], dp[i6][j2 + 1]);
    }
  }
  return dp[0][0];
};
_clearR = new WeakSet();
clearR_fn = function(root) {
  for (const key of Object.keys(root)) {
    if (key == "end") {
      const arr = root["end"];
      while (arr.length > 0)
        arr.pop();
    } else
      __privateMethod(this, _clearR, clearR_fn).call(this, root[key]);
    delete root[key];
  }
};
var NodeComparator = class {
  static SORT_BY_CREATED_AT(node1, node2) {
    if (node1.type != "file" && node2.type != "file")
      return 0;
    if (node1.type != "file")
      return 1;
    if (node2.type != "file")
      return -1;
    return node1.created_at - node2.created_at;
  }
  static SORT_BY_LAST_MODIFIED(node1, node2) {
    if (node1.type != "file" && node2.type != "file")
      return 0;
    if (node1.type != "file")
      return 1;
    if (node2.type != "file")
      return -1;
    return node2.last_modified - node1.last_modified;
  }
  static SORT_BY_NAME(node1, node2) {
    const [t1, t22] = [node1.title.toLowerCase(), node2.title.toLowerCase()];
    if (t1 > t22)
      return 1;
    else if (t1 < t22)
      return -1;
    return 0;
  }
};

// specification/index.ts
var CompositeSpecification = class {
  and(other) {
    return new AndSpecification(this, other);
  }
  or(other) {
    return new OrSpecification(this, other);
  }
  not() {
    return new NotSpecification(this);
  }
};
var AndSpecification = class extends CompositeSpecification {
  constructor(left, right) {
    super();
    this.left = left;
    this.right = right;
  }
  isSatisfied(candidate) {
    return this.left.isSatisfied(candidate) && this.right.isSatisfied(candidate);
  }
};
var OrSpecification = class extends CompositeSpecification {
  constructor(left, right) {
    super();
    this.left = left;
    this.right = right;
  }
  isSatisfied(candidate) {
    return this.left.isSatisfied(candidate) || this.right.isSatisfied(candidate);
  }
};
var NotSpecification = class extends CompositeSpecification {
  constructor(other) {
    super();
    this.other = other;
  }
  isSatisfied(candidate) {
    return !this.other.isSatisfied(candidate);
  }
};
var ExpressionSpecification = class extends CompositeSpecification {
  constructor(callback) {
    super();
    this.callback = callback;
  }
  isSatisfied(candidate) {
    return this.callback(candidate);
  }
};
var AudioSpecification = class extends CompositeSpecification {
  isSatisfied(candidate) {
    if (!candidate.type == "file")
      return false;
    return candidate.extension in FILE_FORMAT.Audio;
  }
};
var ImageSpecification = class extends CompositeSpecification {
  isSatisfied(candidate) {
    if (!candidate.type == "file")
      return false;
    return candidate.extension in FILE_FORMAT.Image;
  }
};
var VideoSpecification = class extends CompositeSpecification {
  isSatisfied(candidate) {
    if (!candidate.type == "file")
      return false;
    return candidate.extension in FILE_FORMAT.Video;
  }
};

// observers/observer.ts
var NodeObserver = class {
  constructor(callback) {
    this.callback = callback;
  }
  update(nodes) {
    this.callback(nodes);
  }
};
var NodeFilterObserver = class {
  constructor(callback) {
    this.callback = callback;
  }
  update(filters) {
    this.callback(filters);
  }
};
var _callback, callback_fn, _addObservableElement, addObservableElement_fn;
var AttributeObserver = class {
  constructor() {
    __privateAdd(this, _callback);
    __privateAdd(this, _addObservableElement);
    this.config = { attributes: true, attributeFilter: ["class"] };
  }
  observe(leaf, node_state) {
    if (!leaf)
      return;
    if (this.observer)
      this.disconnect();
    this.observer = new MutationObserver((mutation) => {
      __privateMethod(this, _callback, callback_fn).call(this, leaf, node_state);
    });
    __privateMethod(this, _addObservableElement, addObservableElement_fn).call(this, leaf);
  }
  disconnect() {
    if (this.observer)
      this.observer.disconnect();
    this.observer = null;
  }
};
_callback = new WeakSet();
callback_fn = function(leaf, node_state) {
  const view_state = leaf.getViewState();
  if (view_state.type != "canvas")
    return;
  const selection = Array.from(
    //@ts-ignore
    leaf.view.canvas.selection,
    //@ts-ignore
    (val) => val.id
  );
  node_state.selectNodes(selection);
};
_addObservableElement = new WeakSet();
addObservableElement_fn = function(leaf) {
  const view_state = leaf.getViewState();
  if (view_state.type != "canvas")
    return;
  const nodes = Array.from(
    //@ts-ignore
    leaf.view.canvas.nodes,
    //@ts-ignore
    ([id3, value]) => ({
      id: id3,
      container: value.nodeEl,
      data: value.unknownData
    })
  );
  if (this.observer) {
    for (const node of nodes) {
      this.observer.observe(node.container, this.config);
    }
  }
};
var _swapIdx, swapIdx_fn, _indexNodes, indexNodes_fn, _clearRelNodes, clearRelNodes_fn, _sort, sort_fn, _order, order_fn, _getFilterSpec, getFilterSpec_fn, _PopulateRelNodes, PopulateRelNodes_fn, _update, update_fn, _findFirstNode, findFirstNode_fn;
var NodesState = class {
  constructor() {
    // List
    __privateAdd(this, _swapIdx);
    __privateAdd(this, _indexNodes);
    __privateAdd(this, _clearRelNodes);
    __privateAdd(this, _sort);
    __privateAdd(this, _order);
    __privateAdd(this, _getFilterSpec);
    __privateAdd(this, _PopulateRelNodes);
    // Search
    __privateAdd(this, _update);
    __privateAdd(this, _findFirstNode);
    this.observers = [];
    this.node_map = /* @__PURE__ */ new Map();
    this.rel_node_map = /* @__PURE__ */ new Map();
    this.node_arr = [];
    this.rel_node_arr = [];
    this.selected = [];
    this.currentID = "";
    this.lastID = "";
    this.node_explorer = new NodesExplorer();
    this.currentSearch = "";
    this.sort_by = "name";
    this.node_order = "asc";
    this.filters = [];
  }
  registerObserver(observer) {
    this.observers.push(observer);
  }
  removeObserver(observer) {
    this.observers = this.observers.filter((val) => val != observer);
  }
  notifyObserver() {
    for (const obs of this.observers) {
      obs.update(this.nodes);
    }
  }
  add(nodes) {
    for (const node of nodes) {
      if (this.node_map.size == 0)
        this.firstID = node.id;
      if (this.selected.includes(node.id))
        node.selected = true;
      this.node_map.set(node.id, this.node_arr.length);
      this.node_arr.push(node);
      this.node_explorer.add(node);
    }
    this.firstID = "";
    if (nodes.length > 0)
      this.firstID = this.node_arr[0].id;
    this.notifyObserver();
  }
  remove(id_list) {
    for (const id3 of id_list) {
      if (this.node_map.has(id3)) {
        __privateMethod(this, _swapIdx, swapIdx_fn).call(this, this.node_map.get(id3), this.node_arr.length - 1);
        const node = this.node_arr.pop();
        if (node)
          this.node_explorer.remove(node);
        this.node_map.delete(id3);
        __privateMethod(this, _swapIdx, swapIdx_fn).call(this, this.node_map.get(id3), this.node_arr.length - 1);
      }
    }
    this.notifyObserver();
  }
  replace(nodes) {
    while (this.node_arr.length > 0)
      this.node_arr.pop();
    this.node_map.clear();
    this.node_explorer.clear();
    this.add(nodes);
  }
  selectNodes(id_list) {
    const n7 = id_list.length;
    this.selected = id_list;
    if (n7 == 0) {
      this.currentID = "";
    } else {
      this.lastID = this.currentID;
      this.currentID = id_list[0];
    }
    for (const node of this.node_arr)
      node.selected = false;
    for (const id3 of id_list) {
      const node_idx = this.node_map.get(id3);
      if (node_idx == void 0)
        continue;
      this.node_arr[node_idx].selected = true;
    }
    this.notifyObserver();
  }
  order(order) {
    if (this.node_order != order) {
      this.node_order = order;
      this.notifyObserver();
    }
  }
  sortBy(sort_by) {
    if (this.sort_by != sort_by) {
      this.sort_by = sort_by;
      this.notifyObserver();
    }
  }
  setFilters(filters) {
    this.filters = filters;
    this.notifyObserver();
  }
  setSearchWord(word) {
    this.currentSearch = word;
    this.notifyObserver();
  }
  // Navigator
  current(id3) {
    this.currentID = id3;
    const idx = this.node_map.get(id3);
    if (idx === void 0)
      return;
    const next_node = this.node_arr[idx];
    if (!next_node.container)
      return;
    next_node.container.click();
  }
  next() {
    const idx = this.rel_node_map.get(this.currentID);
    if (idx === void 0) {
      const next_node2 = __privateMethod(this, _findFirstNode, findFirstNode_fn).call(this);
      if (!next_node2 || !next_node2.container)
        return;
      next_node2.container.click();
      return;
    }
    const next_idx = (idx + 1) % this.rel_node_arr.length;
    const next_node = this.rel_node_arr[next_idx];
    if (!next_node.container)
      return;
    next_node.container.click();
  }
  previous() {
    const idx = this.rel_node_map.get(this.currentID);
    if (idx === void 0) {
      const next_node2 = __privateMethod(this, _findFirstNode, findFirstNode_fn).call(this);
      if (!next_node2 || !next_node2.container)
        return;
      next_node2.container.click();
      return;
    }
    const prev_idx = idx - 1 < 0 ? this.rel_node_arr.length - 1 : idx - 1;
    const next_node = this.rel_node_arr[prev_idx];
    if (!next_node.container)
      return;
    next_node.container.click();
  }
  get nodes() {
    __privateMethod(this, _update, update_fn).call(this);
    return this.rel_node_arr;
  }
  get allNodes() {
    return this.node_arr;
  }
  get selectedNode() {
    const idx = this.node_map.get(this.currentID);
    if (idx == void 0)
      return null;
    return this.node_arr[idx];
  }
  get isNodeSame() {
    if (this.currentID == "" || this.lastID == "")
      return false;
    return this.currentID == this.lastID;
  }
};
_swapIdx = new WeakSet();
swapIdx_fn = function(left, right) {
  const node1 = this.node_arr[left];
  const node2 = this.node_arr[right];
  this.node_map.set(node1.id, right);
  this.node_map.set(node2.id, left);
  [this.node_arr[left], this.node_arr[right]] = [
    this.node_arr[right],
    this.node_arr[left]
  ];
};
_indexNodes = new WeakSet();
indexNodes_fn = function() {
  this.rel_node_map.clear();
  const n7 = this.rel_node_arr.length;
  for (let i6 = 0; i6 < n7; i6++)
    this.rel_node_map.set(this.rel_node_arr[i6].id, i6);
};
_clearRelNodes = new WeakSet();
clearRelNodes_fn = function() {
  while (this.rel_node_arr.length > 0)
    this.rel_node_arr.pop();
};
_sort = new WeakSet();
sort_fn = function() {
  const sort_button = DOMHandler.getSortButton();
  const text = sort_button.querySelector(".sb-text");
  const sort_menu = DOMHandler.getSortMenu();
  const sort_name = sort_menu.querySelector(".s-name");
  const sort_created = sort_menu.querySelector(".s-created");
  const sort_last = sort_menu.querySelector(".s-last");
  for (const node of [sort_name, sort_created, sort_last]) {
    if (!node)
      continue;
    node.classList.remove("check-active");
  }
  switch (this.sort_by) {
    case "name":
      this.rel_node_arr.sort(NodeComparator.SORT_BY_NAME);
      if (text)
        text.setText("Name");
      if (sort_name)
        sort_name.classList.add("check-active");
      break;
    case "created_at":
      this.rel_node_arr.sort(NodeComparator.SORT_BY_CREATED_AT);
      if (text)
        text.setText("Created_at");
      if (sort_created)
        sort_created.classList.add("check-active");
      break;
    case "last_modified":
      this.rel_node_arr.sort(NodeComparator.SORT_BY_LAST_MODIFIED);
      if (text)
        text.setText("Last_modified");
      if (sort_last)
        sort_last.classList.add("check-active");
      break;
    default:
      this.rel_node_arr.sort(NodeComparator.SORT_BY_NAME);
      break;
  }
};
_order = new WeakSet();
order_fn = function() {
  const sort_menu = DOMHandler.getSortMenu();
  const sort_asc = sort_menu.querySelector(".s-asc");
  const sort_desc = sort_menu.querySelector(".s-desc");
  for (const node of [sort_asc, sort_desc]) {
    if (!node)
      continue;
    node.classList.remove("check-active");
  }
  if (this.node_order == "des") {
    this.rel_node_arr.reverse();
    if (sort_desc)
      sort_desc.classList.add("check-active");
  } else {
    if (sort_asc)
      sort_asc.classList.add("check-active");
  }
};
_getFilterSpec = new WeakSet();
getFilterSpec_fn = function() {
  if (this.filters.length == 0)
    return new ExpressionSpecification(() => true);
  let specification = new ExpressionSpecification(() => false);
  for (const filter of this.filters) {
    if (filter.type == "audio") {
      specification = specification.or(
        new AudioSpecification()
      );
    } else if (filter.type == "video") {
      specification = specification.or(
        new VideoSpecification()
      );
    } else if (filter.type == "image") {
      specification = specification.or(
        new ImageSpecification()
      );
    } else {
      const or_specification = new ExpressionSpecification((candidate) => {
        if (candidate.type == "file")
          return candidate.extension == filter.type;
        else
          return candidate.type == filter.type;
      });
      specification = specification.or(or_specification);
    }
  }
  return specification;
};
_PopulateRelNodes = new WeakSet();
PopulateRelNodes_fn = function(nodes) {
  __privateMethod(this, _clearRelNodes, clearRelNodes_fn).call(this);
  const spec = __privateMethod(this, _getFilterSpec, getFilterSpec_fn).call(this);
  for (const node of nodes) {
    if (spec.isSatisfied(node))
      this.rel_node_arr.push(node);
  }
  __privateMethod(this, _sort, sort_fn).call(this);
  __privateMethod(this, _order, order_fn).call(this);
  __privateMethod(this, _indexNodes, indexNodes_fn).call(this);
};
_update = new WeakSet();
update_fn = function() {
  if (this.currentSearch == "")
    __privateMethod(this, _PopulateRelNodes, PopulateRelNodes_fn).call(this, this.node_arr);
  else {
    __privateMethod(this, _PopulateRelNodes, PopulateRelNodes_fn).call(
      this,
      // this.node_explorer.findSimilar(this.currentSearch, 4)
      this.node_explorer.prefixSearch(this.currentSearch)
    );
  }
};
_findFirstNode = new WeakSet();
findFirstNode_fn = function() {
  const id3 = this.rel_node_arr[0].id;
  this.currentID = id3 || "";
  const idx = this.rel_node_map.get(id3);
  if (idx == void 0)
    return null;
  const next_node = this.rel_node_arr[idx];
  if (!next_node.container)
    return null;
  return next_node;
};
var NodesFilterState = class {
  constructor() {
    this.observers = [];
    this.filter_index = /* @__PURE__ */ new Map();
    this.filter_list = [];
    let idx = 0;
    for (const group in FILE_FORMAT) {
      for (const type in FILE_FORMAT[group]) {
        const t7 = type;
        this.filter_list.push(new NodeFilter(group, t7));
        this.filter_index.set(t7, idx++);
      }
    }
  }
  registerObserver(observer) {
    this.observers.push(observer);
  }
  removeObserver(observer) {
    this.observers = this.observers.filter((val) => val != observer);
  }
  notifyObserver() {
    for (const obs of this.observers) {
      obs.update(this.filter_list);
    }
  }
  addFilter(filter) {
    const idx = this.filter_index.get(filter);
    if (!idx)
      return;
    if (this.filter_list[idx].isActive)
      return;
    this.filter_list[idx].enable();
    this.notifyObserver();
  }
  removeFilter(filter) {
    const idx = this.filter_index.get(filter);
    if (!idx)
      return;
    if (!this.filter_list[idx].isActive)
      return;
    this.filter_list[idx].disable();
    this.notifyObserver();
  }
  getFilterByGroup(group) {
    return this.filter_list.filter((val) => val.group == group);
  }
  get activeFilters() {
    return this.filter_list.filter((val) => val.isActive);
  }
  get allFilters() {
    return this.filter_list;
  }
};

// main.ts
var VIEW_TYPE = "crafty-plugin";
var _setBaseLayout, setBaseLayout_fn;
var BaseView = class extends import_obsidian2.ItemView {
  constructor(leaf) {
    super(leaf);
    __privateAdd(this, _setBaseLayout);
  }
  getViewType() {
    return VIEW_TYPE;
  }
  getDisplayText() {
    return "Crafty";
  }
  async onOpen() {
    __privateMethod(this, _setBaseLayout, setBaseLayout_fn).call(this);
  }
  async onClose() {
    DOMHandler.free();
  }
};
_setBaseLayout = new WeakSet();
setBaseLayout_fn = function() {
  const container = this.containerEl.children[1];
  container.empty();
  const tabGroup = container.createEl("sl-tab-group", {
    cls: ["side-bar-nav"]
  });
  const tabs = [];
  for (const tab of ["Edit", "Nodes"]) {
    const tb = tabGroup.createEl("sl-tab", {
      text: tab
    });
    tb.setAttrs({ slot: "nav", panel: tab });
    tabs.push(tb);
  }
  const node_list = tabGroup.createEl("sl-tab-panel", {
    attr: {
      name: "Nodes"
    }
  });
  const nodes_panel = node_list.createEl("div", {
    attr: { class: "nodes-panel " }
  });
  const search_area = nodes_panel.createEl("div", {
    attr: { class: "search-area" }
  });
  const search_bar_row = createEl("div", {
    attr: { class: "search-bar-row" }
  });
  const filter_row = createEl("div", {
    attr: { class: "filter-row" }
  });
  const search_bar = DOMHandler.getSearchBar();
  const sort_button = DOMHandler.getSortButton();
  search_bar_row.appendChild(search_bar);
  search_bar_row.appendChild(sort_button);
  const filters_container = DOMHandler.getFiltersContainer();
  filter_row.appendChild(filters_container);
  search_area.appendChild(search_bar_row);
  search_area.appendChild(filter_row);
  const nodes_container = DOMHandler.getNodesContainer();
  nodes_panel.appendChild(nodes_container);
  const edit_panel = tabGroup.createEl("sl-tab-panel", {
    attr: {
      name: "Edit",
      class: "description-body"
    }
  });
  const edit_header = edit_panel.createEl("div", {
    attr: { class: "description-header-div" }
  });
  const edit_header_display = DOMHandler.getTitleDisplay();
  const edit_header_input = DOMHandler.getTitleInput();
  edit_header.appendChild(edit_header_display);
  edit_header.appendChild(edit_header_input);
  const text_area = DOMHandler.getTextArea();
  const save_state = DOMHandler.getSaveState();
  edit_panel.appendChild(text_area);
  edit_panel.appendChild(save_state);
};
var _updateCurrentFile, updateCurrentFile_fn, _updateCurrentLeaf, updateCurrentLeaf_fn, _trackFileChange, trackFileChange_fn, _syncNodes, syncNodes_fn, _extractNodeData, extractNodeData_fn, _createTitle, createTitle_fn;
var Crafty = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    /**
     * Set current_file to current activeFile
     * @returns void
     */
    __privateAdd(this, _updateCurrentFile);
    /**
     * Set current_canvas_leaf to leaf if leaf is a canvas
     * @param {WorkspaceLeaf} leaf
     */
    __privateAdd(this, _updateCurrentLeaf);
    /**
     * @param {TFile} file
     * Use FSWatcher to listen for change in file
     */
    __privateAdd(this, _trackFileChange);
    /**
     * Extract nodes content from canvas data and update the current the NodesState.
     * @returns
     */
    __privateAdd(this, _syncNodes);
    /**
     * Extract and format id, title and description from  raw_nodes
     * @param raw_nodes
     * @returns Map<string,CraftyNode>
     */
    __privateAdd(this, _extractNodeData);
    /**
     * Create default tile for nodes.
     * @param {string | undefined} text
     * @param {string | undefined} file
     * @param {string | undefined} label
     * @param {string | undefined} url
     * @returns
     */
    __privateAdd(this, _createTitle);
    this.att_observer = null;
    this.file_watcher = null;
    this.node_state = null;
    this.node_filter_state = null;
    this.current_canvas_leaf = null;
    this.GLOBAL_CD = 100;
  }
  async onload() {
    this.node_state = new NodesState();
    this.att_observer = new AttributeObserver();
    this.registerView(VIEW_TYPE, (leaf) => new BaseView(leaf));
    this.node_state = new NodesState();
    this.node_filter_state = new NodesFilterState();
    DOMHandler.setCraftyInstance(this);
    __privateMethod(this, _updateCurrentFile, updateCurrentFile_fn).call(this);
    const filter_listener = new NodeFilterObserver((filters) => {
      const filters_display = DOMHandler.getFiltersDisplay();
      const badges = filters_display.querySelectorAll(
        ".filter-menu-badge-display"
      );
      for (const badge of badges) {
        badge.classList.remove("badge-display-active");
        const span = badge.querySelector("span");
        const value = span.getText();
        const filter = filters.find((val) => val.title == value);
        if (filter && filter.isActive)
          badge.classList.add("badge-display-active");
      }
      if (this.nodeState) {
        this.nodeState.setFilters(
          filters.filter((val) => val.isActive)
        );
      }
    });
    const description_listener = new NodeObserver(
      (0, import_obsidian2.debounce)(
        (nodes) => {
          var _a6;
          if (!this.node_state)
            return;
          const all_nodes = this.node_state.allNodes;
          for (const node of all_nodes) {
            if (!node.container)
              continue;
            if (node.description != "") {
              node.container.setAttribute(
                "aria-label",
                `${node.description}`
              );
            } else {
              (_a6 = node.container) == null ? void 0 : _a6.removeAttribute("aria-label");
            }
          }
        },
        this.GLOBAL_CD,
        true
      )
    );
    const sidebar_node_listener = new NodeObserver(
      (0, import_obsidian2.debounce)(
        (nodes) => {
          DOMHandler.populateNodes(nodes);
          if (!this.att_observer)
            return;
          this.att_observer.observe(
            this.current_canvas_leaf,
            //@ts-ignore
            this.node_state
          );
        },
        this.GLOBAL_CD,
        true
      )
    );
    const sidebar_description_listener = new NodeObserver(
      (0, import_obsidian2.debounce)(
        (nodes) => {
          if (!this.node_state)
            return;
          if (!this.node_state.selectedNode)
            DOMHandler.showEmptyEdit();
          else
            DOMHandler.showSelectedNode();
        },
        this.GLOBAL_CD,
        true
      )
    );
    this.node_state.registerObserver(description_listener);
    this.node_state.registerObserver(sidebar_node_listener);
    this.node_state.registerObserver(sidebar_description_listener);
    this.node_filter_state.registerObserver(filter_listener);
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        var _a6;
        if (!leaf)
          return;
        const view_state = leaf.getViewState();
        if (view_state.type != "canvas")
          return;
        if (leaf == this.current_canvas_leaf)
          return;
        __privateMethod(this, _updateCurrentFile, updateCurrentFile_fn).call(this);
        __privateMethod(this, _updateCurrentLeaf, updateCurrentLeaf_fn).call(this, null);
        __privateMethod(this, _trackFileChange, trackFileChange_fn).call(this, null);
        if (this.current_file.extension == "canvas")
          __privateMethod(this, _syncNodes, syncNodes_fn).call(this);
        (_a6 = this.att_observer) == null ? void 0 : _a6.observe(
          this.current_canvas_leaf,
          //@ts-ignore
          this.node_state
        );
      })
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        var _a6;
        __privateMethod(this, _updateCurrentFile, updateCurrentFile_fn).call(this);
        __privateMethod(this, _updateCurrentLeaf, updateCurrentLeaf_fn).call(this, null);
        __privateMethod(this, _trackFileChange, trackFileChange_fn).call(this, null);
        if (this.current_file.extension == "canvas") {
          __privateMethod(this, _syncNodes, syncNodes_fn).call(this);
          (_a6 = this.att_observer) == null ? void 0 : _a6.observe(
            this.current_canvas_leaf,
            //@ts-ignore
            this.node_state
          );
          DOMHandler.showSelectedNode();
          DOMHandler.showNodes();
        } else {
          DOMHandler.showEmptyEdit();
          DOMHandler.showEmptyNodes();
        }
      })
    );
    this.addCommand({
      id: "next-node",
      name: "Next node",
      callback: () => {
        if (!this.node_state)
          return;
        DOMHandler.hideTitle();
        this.node_state.next();
      }
    });
    this.addCommand({
      id: "prev-node",
      name: "Prev node",
      callback: () => {
        if (!this.node_state)
          return;
        DOMHandler.hideTitle();
        this.node_state.previous();
      }
    });
    this.addCommand({
      id: "show-panel",
      name: "Show Panel",
      callback: async () => {
        const rightSplit = this.app.workspace.rightSplit;
        const sidebar_leaf = this.sidebarLeaf;
        if (rightSplit.collapsed || !sidebar_leaf) {
          setTimeout(() => {
            this.activateView();
          }, 50);
          if (rightSplit.collapsed)
            rightSplit.expand();
        } else {
          this.closeView();
        }
      }
    });
  }
  /**
   * Show sidebar
   */
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await leaf.setViewState({ type: VIEW_TYPE, active: true });
    }
    workspace.revealLeaf(leaf);
    __privateMethod(this, _updateCurrentFile, updateCurrentFile_fn).call(this);
    __privateMethod(this, _updateCurrentLeaf, updateCurrentLeaf_fn).call(this, null);
    __privateMethod(this, _trackFileChange, trackFileChange_fn).call(this, null);
    __privateMethod(this, _syncNodes, syncNodes_fn).call(this);
  }
  /**
   * Hide sidebar
   */
  async closeView() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE);
    if (leaves.length < 1)
      return;
    leaves[0].detach();
  }
  get sidebarLeaf() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE);
    if (leaves.length < 1)
      return;
    return leaves[0];
  }
  getFileObserver() {
    return this.file_watcher;
  }
  getAttributeObserver() {
    return this.att_observer;
  }
  onunload() {
    if (this.file_watcher)
      this.file_watcher.close();
    if (this.att_observer)
      this.att_observer.disconnect();
    DOMHandler.free();
  }
  get vault() {
    return this.app.vault;
  }
  get selectedNode() {
    if (!this.node_state)
      return null;
    return this.node_state.selectedNode;
  }
  get currentFile() {
    return this.current_file;
  }
  get nodeState() {
    return this.node_state;
  }
  get nodeFilterState() {
    return this.node_filter_state;
  }
};
_updateCurrentFile = new WeakSet();
updateCurrentFile_fn = function() {
  const file = this.app.workspace.getActiveFile();
  if (!file)
    return;
  this.current_file = file;
};
_updateCurrentLeaf = new WeakSet();
updateCurrentLeaf_fn = function(leaf) {
  if (!leaf) {
    this.app.workspace.iterateAllLeaves((leaf2) => {
      const view_state2 = leaf2.getViewState();
      if (view_state2.type != "canvas")
        return;
      const classList = leaf2.containerEl.classList;
      if (!/mod-active/.test(classList.value))
        return;
      this.current_canvas_leaf = leaf2;
    });
    return;
  }
  const view_state = leaf.getViewState();
  if (view_state.type != "canvas")
    return;
  this.current_canvas_leaf = leaf;
};
_trackFileChange = new WeakSet();
trackFileChange_fn = function(file) {
  if (!file && !this.current_file)
    return;
  if (!file)
    file = this.current_file;
  const path = `${file.vault.adapter.basePath}/${file.path}`;
  if (this.file_watcher)
    this.file_watcher.close();
  this.file_watcher = (0, import_fs.watch)(
    path,
    (0, import_obsidian2.debounce)(async (event) => __privateMethod(this, _syncNodes, syncNodes_fn).call(this), this.GLOBAL_CD)
  );
};
_syncNodes = new WeakSet();
syncNodes_fn = function() {
  if (!this.current_canvas_leaf || //@ts-ignore
  !this.current_canvas_leaf.view.canvas) {
    return;
  }
  if (!this.node_state)
    return;
  const canvas_data = this.current_canvas_leaf.view.canvas;
  const raw_nodes_map = __privateMethod(this, _extractNodeData, extractNodeData_fn).call(this, canvas_data);
  const selection = Array.from(
    //@ts-ignore
    this.current_canvas_leaf.view.canvas.selection
    //@ts-ignore
  ).map((val) => val.id);
  if (!raw_nodes_map) {
    this.node_state.replace([]);
    this.node_state.selectNodes([]);
    return;
  }
  const nodes = Array.from(
    //@ts-ignore
    this.current_canvas_leaf.view.canvas.nodes,
    //@ts-ignore
    ([key, val]) => {
      const node = raw_nodes_map.get(key);
      return {
        id: key,
        title: (node == null ? void 0 : node.title) || "Untitled",
        description: (node == null ? void 0 : node.description) || "",
        selected: selection.includes(key),
        container: val.nodeEl,
        type: (node == null ? void 0 : node.type) || "",
        extension: (node == null ? void 0 : node.extension) || "",
        created_at: (node == null ? void 0 : node.created_at) || 0,
        last_modified: (node == null ? void 0 : node.last_modified) || 0
      };
    }
  );
  this.node_state.replace(nodes);
  this.node_state.selectNodes(selection);
};
_extractNodeData = new WeakSet();
extractNodeData_fn = function(canvas) {
  const raw_node_map = /* @__PURE__ */ new Map();
  if (!canvas)
    return raw_node_map;
  const data = canvas.data.nodes;
  const stats = canvas.nodes;
  for (const el of data) {
    const file_stats = stats.get(el.id).file;
    raw_node_map.set(el.id, {
      id: el.id,
      title: el.title || __privateMethod(this, _createTitle, createTitle_fn).call(this, el.text, el.file, el.label, el.url),
      description: el.description || "",
      type: el.type,
      extension: el.file ? el.file.split(".").pop() || "" : "",
      created_at: file_stats ? file_stats.stat.ctime : 0,
      last_modified: file_stats ? file_stats.stat.mtime : 0,
      selected: false,
      container: null
    });
  }
  return raw_node_map;
};
_createTitle = new WeakSet();
createTitle_fn = function(text, file, label, url) {
  if (file != void 0)
    return (file == null ? void 0 : file.split("/").pop()) || "Untitled";
  return text || label || url || "Untitled";
};
/*! Bundled license information:

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/class-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/static.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/if-defined.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/live.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/style-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/unsafe-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/


/* nosourcemap */